<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>A WSL Error Encountered When Installing Docker</title>
      <link href="/2025/04/07/A-WSL-Error-Encountered-When-installing-Docker/"/>
      <url>/2025/04/07/A-WSL-Error-Encountered-When-installing-Docker/</url>
      
        <content type="html"><![CDATA[<p>This document explains the problems the author had installing Docker and how to solve them. You can find and download the installation package for Docker <a href="https://www.docker.com/">here</a>.</p><p>After installing Docker, an <code>Unexpected WSL error</code> was encountered, and the process was terminated. After conducting some online research, I discovered that this error message was indicating that I needed to enable the <strong>Hyper-V</strong>, <strong>Windows Subsystem for Linux</strong> and <strong>Virtual Machine Platform</strong> functions on my system. I opened the configuration panel and found that the latter two functions had been properly enabled, but the option for the first one was missing. It took me a some time to find the solution.</p><p>To address the issue, it was necessary to create and run a file named <code>Hyper-V.bat</code> as administrator, which contains the following content:</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> &quot;%~dp0&quot;</span><br><span class="line"><span class="built_in">dir</span> /b <span class="variable">%SystemRoot%</span>\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"><span class="keyword">for</span> /f <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">findstr</span> /i . hyper-v.txt <span class="number">2</span>^&gt;<span class="built_in">nul</span>&#x27;) <span class="keyword">do</span> dism /online /norestart /add-package:&quot;<span class="variable">%SystemRoot%</span>\servicing\Packages\<span class="variable">%%i</span>&quot;</span><br><span class="line"><span class="built_in">del</span> hyper-v.txt</span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure><p>The program will then require you to restart your machine, at which point you will see that Hyper-V is properly enabled. But Docker still cannot run normally.</p><p>After that, you need to install WSL2. To do this, run the following command:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsl --install# may require VPN</span><br><span class="line">wsl --<span class="built_in">set</span>-default-version <span class="number">2</span># <span class="built_in">set</span> the default wsl version to wsl2</span><br><span class="line">wsl --update# may <span class="keyword">not</span> be necessary</span><br></pre></td></tr></table></figure><p>Finally, Docker can run without any problems after all this work.</p><hr><p>Off topic:</p><p>When using the VSCode extension <code>Remote Containers</code> to set up containers, you might encounter the message “the container does not meet all the requirements of the VS Code Server”. This happens because VSCode has increased the minimum requirements for remote server build toolchain since version 1.86. To solve the problem, just downgrade your VSCode to a version below 1.86. You can download version 1.85.2 <a href="https://update.code.visualstudio.com/1.85.2/win32-x64-archive/stable">here</a>. Besides, it is necessary to downgrade your extensions as well.</p>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to Program Analysis</title>
      <link href="/2025/04/07/Introduction-to-Program-Analysis/"/>
      <url>/2025/04/07/Introduction-to-Program-Analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="01-What-Is-Program-Analysis"><a href="#01-What-Is-Program-Analysis" class="headerlink" title="01 What Is Program Analysis"></a>01 What Is Program Analysis</h2><p>Program analysis is to discover useful facts about programs. You probably have known some manual or automated testing tools like:</p><ul><li><p>Manual testing or semi-automated testing: JUnit, Selenium, etc.</p></li><li><p>Manual “analysis” of programs: Code inspection, debugging, etc.</p></li></ul><p>The focus of this course is <strong>automated</strong> program analysis.</p><p>Program analysis can be broadly classified into three kinds:</p><ul><li><p>Static (compile-time)</p><ul><li>Infer facts by inspecting source or binary code</li><li>Typically:<ul><li>Consider all inputs</li><li>Overapproximate possible behavior</li></ul></li><li>E.g. compilers, lint-like tools</li></ul></li><li><p>Dynamic (execution-time)</p><ul><li>Infer facts by monitoring program executions</li><li>Typically:<ul><li>Consider current input</li><li>Underapproximate possible behavior</li></ul></li><li>E.g. automated testing tools, profilers</li></ul></li><li><p>Hybrid (combining dynamic and static)</p></li></ul><h2 id="02-Terminology"><a href="#02-Terminology" class="headerlink" title="02 Terminology"></a>02 Terminology</h2><p>The following is a snippet of JavaScript code.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="title class_">Math</span>.<span class="title function_">random</span>();<span class="comment">//value in [0,1)</span></span><br><span class="line"><span class="keyword">var</span> out = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0.5</span>)</span><br><span class="line">out = <span class="string">&quot;no&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(r == <span class="number">1</span>)</span><br><span class="line">out = <span class="string">&quot;maybe&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(out);</span><br></pre></td></tr></table></figure><p>Q: What are the possible outputs?</p><h3 id="2-1-Overapproximation-v-s-Underapproximation"><a href="#2-1-Overapproximation-v-s-Underapproximation" class="headerlink" title="2.1 Overapproximation v.s. Underapproximation"></a>2.1 Overapproximation v.s. Underapproximation</h3><p>Judging from the static code, it seems that there are three possible outputs: “yes”, “no” or “maybe”. (Overapproximation)</p><p>If we consider the case of only one execution like <code>r=0.7</code>, its output is “yes”. (Underapproximation)</p><p>However, both responses are erroneous. The first option yields the implausible output “maybe”, while the second excludes the feasible output “no”. These erroneous responses serve as quintessential illustrations of over- and under-approximation, respectively.</p><ul><li>Overapproximation: Consider all paths</li><li>Underapproximation: Execute the program once</li></ul><h3 id="2-2-Soundness-amp-Completeness"><a href="#2-2-Soundness-amp-Completeness" class="headerlink" title="2.2 Soundness &amp; Completeness"></a>2.2 Soundness &amp; Completeness</h3><p>It is easy for us humans to give the right answer —— “yes” or “no”. We think these answers are <strong>sound</strong> and <strong>complete</strong>.</p><p>“Soundness” means it contains all the possible outputs we want (might give <strong>false positives</strong>).</p><p>“Completeness” means it excludes all the impossible outputs we do not want (might give <strong>false negtives</strong>).</p><p>When we put these two ideas together, we get a definition that includes exactly all possible outputs.</p><h3 id="2-3-False-Positives-amp-False-Negatives"><a href="#2-3-False-Positives-amp-False-Negatives" class="headerlink" title="2.3 False Positives &amp; False Negatives"></a>2.3 False Positives &amp; False Negatives</h3><p>The definitions of false positives and false negatives:</p><ul><li>False positives: impossible outputs that are indicated possible</li><li>False negatives: possible outputs that are indicated impossible</li></ul><p>Let $P$ be <em>Program</em>, $i$ be <em>Input</em>, $P(i)$ be <em>Behavior</em>. The following graph shows the relations between the above ideas.</p><p><img src="/img/Introduction-to-Program-Analysis-01.png" alt=""></p><h3 id="2-4-Precision-amp-Recall"><a href="#2-4-Precision-amp-Recall" class="headerlink" title="2.4 Precision &amp; Recall"></a>2.4 Precision &amp; Recall</h3><p>Differentiate precision and recall:</p><ul><li><p>Precision: how many retrieved items are relevant</p></li><li><p>Recall: how many relevant items are retrieved</p></li></ul><p>Take the overapproximated answer aforementioned for instance, the precision and the recall are:</p><script type="math/tex; mode=display">\mathrm{precision}=\frac{2}{3}=0.67</script><script type="math/tex; mode=display">\mathrm{recall}=\frac{1}{2}=0.5</script><h3 id="2-5-Program-Invariants"><a href="#2-5-Program-Invariants" class="headerlink" title="2.5 Program Invariants"></a>2.5 Program Invariants</h3><p>Program Invariants are logical assertions whose certain conditions or properties remain true throughout the execution of a program. These invariants are key to program correctness. They help verify that the program behaves as expected and play an important role in software development.</p><p>See the below code snippet:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (getc() == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    z = p(<span class="number">6</span>) + <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    z = p(<span class="number">-7</span>) - <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q: An invariant at the end of the program is <code>(z == c)</code> for some constant <code>c</code>. What is <code>c</code>?</p><p>Clearly, the <code>z</code> will yield <code>42</code> regardless of any inputs. Therefore, <code>(z == 42)</code> is definitely an invariant, while <code>(z == 30)</code> is definitely not an invariant.</p><p>Using the invariant to avert disaster:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (getc() == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    z = p(<span class="number">6</span>) + <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    z = p(<span class="number">-7</span>) - <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (z != <span class="number">42</span>) &#123;</span><br><span class="line">        disaster();<span class="comment">// disaster averted</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="03-Others"><a href="#03-Others" class="headerlink" title="03 Others"></a>03 Others</h2><h3 id="3-1-Undecidability-of-Program-Properties"><a href="#3-1-Undecidability-of-Program-Properties" class="headerlink" title="3.1 Undecidability of Program Properties"></a>3.1 Undecidability of Program Properties</h3><ul><li>Q: Can program analysis be sound and complete? A: Not if we want it to terminate!</li><li>Questions like “is a program point reachable on some input?” are <strong>undecidable</strong>.</li><li>Designing a program analysis is an art —— tradeoffs dictated by consumer.</li></ul><h3 id="3-2-Why-Take-This-Course"><a href="#3-2-Why-Take-This-Course" class="headerlink" title="3.2 Why Take This Course?"></a>3.2 Why Take This Course?</h3><ul><li><p>Learn methods to improve software quality, reliability, security, performance, etc.</p></li><li><p>Become a better software developer/tester</p></li><li>Build specialized tools for software analysis, testing and verification</li><li>Finding Jobs &amp; Do research</li></ul><h3 id="3-3-Who-Needs-Program-Analysis"><a href="#3-3-Who-Needs-Program-Analysis" class="headerlink" title="3.3 Who Needs Program Analysis?"></a>3.3 Who Needs Program Analysis?</h3><p>Three primary consumers of program analysis:</p><ul><li>Compilers</li><li><strong>Software Quality Tools (Primary focus of this course)</strong></li><li>Integrated Development Environments (IDEs)</li></ul><h4 id="3-3-1-Compilers"><a href="#3-3-1-Compilers" class="headerlink" title="3.3.1 Compilers"></a>3.3.1 Compilers</h4><p>Program analysis serves as the bridge between high-level languages and architectures.</p><p>For example, we use program analysis to generate efficient code.</p><p>Before:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (arg != <span class="number">0</span>)</span><br><span class="line">    z = p(<span class="number">6</span>) + <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    z = p(<span class="number">-7</span>) - <span class="number">7</span>;</span><br><span class="line">    print (z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">p</span><span class="params">(<span class="type">int</span> x)</span> &#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">print (<span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-Software-Quality-Tools"><a href="#3-3-2-Software-Quality-Tools" class="headerlink" title="3.3.2 Software Quality Tools"></a>3.3.2 Software Quality Tools</h4><p>Software quality tools are tools for testing, debugging, and verification.</p><p>Software quality tools use program analysis for:</p><ul><li>Finding programming errors</li><li>Proving program invariants</li><li>Generating test cases</li><li>Localizing causes of errors</li><li>…</li></ul><p>Some software quality tools:</p><ul><li>Static Program Analysis<ul><li>Suspicious error patterns: <em>Lint</em>, <em>SpotBugs</em>, <em>Coverity</em></li><li>Memory leak detection: <em>Facebook Infer</em></li><li>Checking API usage rules: <em>Microsoft SLAM</em></li><li>Verifying invariants: <em>ESC/Java</em></li></ul></li><li>Dynamic Program Analysis<ul><li>Array bound checking: <em>Purify</em></li><li>Datarace detection: <em>Eraser</em></li><li>Memory leak detection: <em>Valgrind</em></li><li>Finding likely invariants: <em>Daikon</em></li></ul></li></ul><h4 id="3-3-3-Integrated-Development-Environments"><a href="#3-3-3-Integrated-Development-Environments" class="headerlink" title="3.3.3 Integrated Development Environments"></a>3.3.3 Integrated Development Environments</h4><p>Examples: <em>Eclipse</em> and <em>VS Code</em></p><p>Use program analysis to help programmers:</p><ul><li>Understand programs</li><li>Refactor programs<ul><li>Restructuring a program without changing its behavior</li></ul></li></ul><p>Useful in dealing with large, complex programs</p><h2 id="04-Quiz"><a href="#04-Quiz" class="headerlink" title="04 Quiz"></a>04 Quiz</h2><ul><li>Dynamic vs. Static Analysis:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Dynamic</th><th style="text-align:center">Static</th></tr></thead><tbody><tr><td style="text-align:center">Cost</td><td style="text-align:center"><u>Proportional to program’s execution time</u></td><td style="text-align:center"><u>Proportional to program’s size</u></td></tr><tr><td style="text-align:center">Effectiveness</td><td style="text-align:center"><u>Unsound (may miss errors)</u></td><td style="text-align:center"><u>Incomplete (may report spurious errors)</u></td></tr></tbody></table></div><ul><li>Unsoundness yields <u>false negatives</u>; incompleteness yields <u>false positives</u>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Analysis, Testing and Verification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lecture note </tag>
            
            <tag> software analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECNU软件工程学硕复试复盘</title>
      <link href="/2025/03/23/ECNU%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E7%A1%95%E5%A4%8D%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/03/23/ECNU%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E7%A1%95%E5%A4%8D%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>现在是25年3月23日晚上，研究生复试正式结束！趁着大脑里还留有复试的余温（或者说余震？），复盘一下整个复试历程。</p><h2 id="1-分数构成"><a href="#1-分数构成" class="headerlink" title="1 分数构成"></a>1 分数构成</h2><p>学硕复试的分数构成较为复杂，主要分为笔试、专业知识考察、英语面试，其中：</p><ul><li>笔试卷面分满分100分，考察科目为算法、OS、软工和离散，每个科目25分</li><li>专业知识考察总分=40%×机试分+60%×面试分，其中：机试共3道题，每题100分共300分，按样例给分，最后会根据排名进行赋分，满分100分；专业面试共100分，包括PPT个人介绍和专业知识提问。</li><li>英语面满分100分，包括文献翻译和专业知识提问。</li></ul><p>最终复试分=笔试+专业知识考察+英语面</p><h2 id="2-笔试"><a href="#2-笔试" class="headerlink" title="2 笔试"></a>2 笔试</h2><p>笔试考察科目为算法、OS、软工和离散，每个科目25分，其中算法和OS较简单，离散稍难，软工要看你有没有学过这本书，反正我是没学过，准备复试期间也没有把重心放在这门课上，最后只是把能写的写了。</p><p>算法：</p><ol><li>写出冒泡排序、快速排序、归并排序的渐进时间复杂度</li><li>给出一棵有$n$个结点的二叉树的高度$h$的取值范围</li><li>写出快速排序的伪代码</li></ol><p>OS：</p><ol><li>解释进程互斥和进程同步的概念，并举例说明应用场景</li><li>解释信号量和互斥锁的区别</li><li>解释一下局部性原理及其在操作系统中的体现</li><li>请求分页机制：逻辑地址转物理地址；说出在地址转换过程中的可能发生的问题</li><li>给了一段fork()代码，第一小题要求说明可能的输出和原因，第二小题要求说明父进程和子进程对变量x的修改是否会相互影响，代码大致如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//子进程创建成功</span></span><br><span class="line">x += <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child %d&quot;</span>, x);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//父进程创建成功</span></span><br><span class="line">x -= <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent %d&quot;</span>, x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//进程创建失败</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软工：</p><ol><li>说明瀑布模型和敏捷开发的区别</li><li>某团队在开发系统时频繁遭遇需求变更，导致项目延期，请你分析会产生这种结果的原因，并给出改进方案</li><li>假设某系统需要实现高并发，请从体系架构角度提出优化建议</li><li>请解释设计模式的概念和分类</li><li>请解释git、github和gitlab的概念</li></ol><p>离散：</p><ol><li>五道与谓词逻辑有关的判断题，具体内容忘了</li><li>定义两种集合运算：$A\oplus B=\{a+b|a\in A,b\in B\}$，$A\otimes B=\{a\times b|a\in A,b\in B\}$。请给出下面表达式的结果：$\mathrm{N}\oplus \emptyset$；$\mathrm{N}\oplus \mathrm{N}$；$\mathrm{N}^+\oplus \mathrm{N}^+$；$\mathrm{N}^+\otimes \mathrm{N}^+$</li><li>$\{Z\times Z\times Z\}-\{R^+\times R^+\times R^+\}$的结果是有限集or可数无限集or不可数无限集，请解释原因</li><li>在定义在$n$个元素的集合上的所有关系中，存在多少个反对称关系？存在多少个自反对称关系？</li><li>计算多元函数解的个数，第一题很常规，大概就是$x_i&gt;n$，第二题的约束有3个，均形如$a&lt;x_i&lt;b$</li></ol><h2 id="3-机试"><a href="#3-机试" class="headerlink" title="3 机试"></a>3 机试</h2><p>ECNU的机试是出了名的难，不过今年好像手下留情了。笔试总共考3道题（学硕专硕是一套题），按往年一般是1mid2hard甚至是3hard的难度，不过25年出题人稍微手软了一点，大致是1easy1mid1hard，算是比较幸运了，下面是考题回忆版：</p><ol><li>小花狮和机器学习：这道题的题目很长，还给了很多公式，相当唬人，但其实就是很简单的implementation。具体题目已经记不清了，反正只需要按要求实现3个函数，第三个函数就是用前一个函数计算出来的结果（一个整数$x$），去和一个给定的$n*n$的下三角行列式相乘就行了。由于数和行列式相乘时需要计算$x^n$，所以唯一的优化点在于快速幂，直接套模板就行。（感谢今年软院不杀之恩，让我这种没打过ACM的菜鸡也能十分钟ac一道题，听说有些人被题面唬住了以为是数论，直接跳过了hh）</li><li>小花狮和纸牌：给定$n$个选手的名字以及它们手里的3张扑克牌，扑克牌由小到大排列为$[3,4,5,6,7,8,9,10,J,Q,K,A,2]$。如果选手手里的3张牌都一样，则称为豹子；如果有2张牌一样，则称为对子；如果都不一样，则称为散牌。比大小时，首先遵循豹子&gt;对子&gt;散牌；如果都是豹子，则看谁的牌面比较大；如果都是对子，则先比较构成对子的牌的牌面大小，如果一样，就比较剩下那张牌的大小；如果是散牌，则依次比较双方最大的牌、次大的牌、最小的牌。如果所有牌都相同，则姓名字典序小的选手获胜。请根据上述规则，给主全部选手的排名。（个人思路是排序，但是这样只拿了45分，会TLE）</li><li>小花狮和图论：给定一张无向带权连通图，小花狮想找出能使各个结点连通的最小代价，并计算总代价；但是小花狮学会了一种魔法，可以将图中一条边$(a,b)$的代价变为$a\&amp;b$，但是只能变一次。请计算最小代价。（应该就是找最小生成树，只是加了个可以改变代价的设定，感觉不难，想用dfs暴力骗分，但是有点小问题，找了很久找不出来，现场的编译器环境没配好不好调试，爆零了）</li></ol><h2 id="4-面试"><a href="#4-面试" class="headerlink" title="4 面试"></a>4 面试</h2><p>面试有两个，一个是思政面，大概10min，这个不计入总成绩，只是单纯唠嗑，看你这个人思想是否端正，随便聊就行。</p><p>另一个是专业面，大概10~20min，专业面分为PPT自我介绍+英语面+专业知识提问。需要准备PPT和个人介绍的纸质资料，个人介绍的要求蛮多的，要自己设置封面和目录，具体见复试通知。自我介绍完之后会让你抽英语文献片段进行朗读和翻译，我抽到的内容好像是关于文本加密的，蛮难的，不过我英语还算好，虽然磕磕绊绊但也算翻完了。之后还问了一个英语问题，是让我解释项目中运用到的模型的原理，这个我就不行了，主要是一些专业词汇不会翻译，最后只是说了两句话就结束了。</p><p>专业知识提问主要是围绕你简历上的内容展开的，我是只被提问了项目内容。我的国创项目是基于时空图卷积网络做了一个体育动作矫正系统，主要被问了这些问题：</p><ol><li>你们是如何进行数据清洗的？</li><li>错误动作的衡量标准是什么？</li><li>你的主要贡献是什么？</li><li>模型在数据集上的准确率是88%，但是实际应用中的准确率只有80%，你觉得原因在哪？</li><li>后续会如何改进？</li><li>解释一下时空图卷积网络的原理</li><li>你有什么感兴趣的研究方向，有做过这方面的了解吗？</li></ol><p>老师的问题我基本都能回答上来（除了那个英文问答），问题的深度没有我想的那么深，所以总体还算顺利，加上我语速比较快，感觉没过多久就结束了。面试的老师们都很和蔼，没有因为我的本科出身刁难我（当然也可能是因为我是最后一个面的所以老师们急着下班吃饭）。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>我的考研经历用八个字概括就是“跌宕起伏，有惊无险”。我在24年上半年还在忙项目和比赛，正式的考研复习其实拖到6月份才开始，所以满打满算我只准备了半年。因为时间很仓促，所以我用的是速成法，即快速过完基础和强化阶段的知识点，然后开始集中式刷题。24年的暑假大概是我学习强度最高的一段时间，拼了命地赶数学和408的进度，最后成功在暑假期间结束了数学和408的一轮复习。中间我刷了近十年的英二真题，觉得太简单了就换了英一，挑战ECNU软件工程学硕。我选择ECNU软学的原因：</p><ol><li>学科实力，ECNU软件工程学科评估为A；</li><li>考试科目为12408，可以充分发挥我英语的优势；</li><li>学硕机试占比低，ECNU的机试是出了名的难，我并没有打过ACM，所以打算避开这点；</li><li>我的项目经历和竞赛成绩还算丰富，四六级分数也较高，复试并非完全没有优势；</li><li>ECNU不歧视本科出身，老师们都很和蔼。</li></ol><p>初试考完后感觉数学还行，408很糟糕，实际上刚刚好反一下，数学考得不如预期，408反而还不错，呃呃呃，感觉这辈子都学不会数学了……好在，今年英一是近十年最难的一次，大多数人都只考了五六十分，七十分都已经算高分，不过它难任它难，我考得高就行，英语弥补了我数学上的弱势，充分证明了跳车英一的选择是多么明智。本来我觉得自己是没机会的，工作都找好了，结果我以去年的录取平均分进入了复试名单，具体情况是招14进18排10，算是一个比较危险的名次。于是我火速辞职回来准备复试。</p><p>ECNU软学的复试压力是比较大的，初复试比为6:4，复试分为机试笔试面试。笔试占复试的大头，而且考的是四本计算机经典大黑书，每本都有八百页。其中，我本科学习的离散数学是阉割版，不全面，需要恶补，软工更是整本书没学过，而且学院还不划考试范围，让我在准备复试时焦头烂额，最后我只能找来了一些ECNU本科生的授课课件和期末考卷，然后对照着进行复习。复试之后的感受是：</p><ol><li>笔试，算法和OS还算简单，软工能写的都写了，离散比较难，我答的就是屎；</li><li>机试，今年有一道很唬人的easy题，唯一的优化点在于快速幂，我十分钟就ac了，后面的题用暴力也拿了点分，最后机试排名应该还行；</li><li>面试，老师的提问完全围绕我的国创项目展开，我基本都能答上，问题的深度也没有我想的那么深，算是相当顺利，英语面是文献翻译+英文问答，文献翻译比较难，但是我翻得大差不差，英文提问让我回答我项目里使用的某个模型的原理，这个就算是用中文都难更别提英文了，所以只说了两句话就结束了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> casual </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
