<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>离散数学 | Jiahao Peng</title>
  <meta name="author" content="me">
  
  <meta name="description" content="这篇笔记完成于ECNU研究生复试准备期间，参考书目为Kenneth H.Rosen版《离散数学及其应用》，仅选取了ECNU本科生教学内容">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="离散数学"/>
  <meta property="og:site_name" content="Jiahao Peng"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Jiahao Peng" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/css/themes/lumen.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css">
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
  <![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>
  
  
  <!-- analytics -->
  



<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">Jiahao Peng</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
    <div class="content">
      


	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> 离散数学</h1>
		</div>		
	






<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> <p>这篇笔记完成于ECNU研究生复试准备期间，参考书目为Kenneth
H.Rosen版《离散数学及其应用》，仅选取了ECNU本科生教学内容</p>
			
		 </div> <!-- alert -->
	  		

	  <p>本篇笔记的参考书目为Kenneth
H.Rosen版《离散数学及其应用》，主要内容包括逻辑和证明、集合、计数、递推关系式、容斥原理、关系、图论。</p>
<h2 id="逻辑和证明">01 逻辑和证明</h2>
<h3 id="命题逻辑">1.1 命题逻辑</h3>
<blockquote>
<p>概念：命题、原子命题、命题变元、命题真值、逻辑运算符（否定、合取、析取、条件、双条件）、真值表、永真式、矛盾式、可能式</p>
</blockquote>
<p>逻辑等价式：1.证明逻辑表达式等价：真值表相同；构造逻辑等价式。2.若
<span class="math inline"><em>p</em> ↔︎ <em>q</em></span> 是永真式，则
<span
class="math inline"><em>p</em> ≡ <em>q</em></span>。3.德·摩根律、分配律、结合律。</p>
<p>重要逻辑等价式：<span
class="math inline"><em>p</em> → <em>q</em> ≡ ¬<em>p</em> ∨ <em>q</em></span>；<span
class="math inline"><em>p</em> ↔︎ <em>q</em> ≡ <em>p</em> → <em>q</em> ∧ <em>q</em> → <em>p</em> ≡ (<em>p</em>∧<em>q</em>) ∨ (¬<em>p</em>∧¬<em>q</em>)</span>。</p>
<p>对偶（dual）：将命题公式 <span class="math inline"><em>A</em></span>
中的全部 <span class="math inline">∨</span> 换成 <span
class="math inline">∧</span>，<span class="math inline">∧</span> 换成
<span class="math inline">∨</span>，<span
class="math inline"><em>F</em></span> 换成 <span
class="math inline"><em>T</em></span>，<span
class="math inline"><em>T</em></span> 换成 <span
class="math inline"><em>F</em></span>，得到其对偶命题 <span
class="math inline"><em>A</em><sup>*</sup></span>。</p>
<span id="more"></span>
<p>对偶定理：</p>
<ol type="1">
<li><span
class="math inline">¬<em>A</em>(<em>P</em><sub>1</sub>,<em>P</em><sub>2</sub>,…,<em>P</em><sub><em>n</em></sub>) ⇔ <em>A</em><sup>*</sup>(¬<em>P</em><sub>1</sub>,¬<em>P</em><sub>2</sub>,…,¬<em>P</em><sub><em>n</em></sub>)</span>；<span
class="math inline"><em>A</em>(¬<em>P</em><sub>1</sub>,¬<em>P</em><sub>2</sub>,…,¬<em>P</em><sub><em>n</em></sub>) ⇔ ¬<em>A</em><sup>*</sup>(<em>P</em><sub>1</sub>,<em>P</em><sub>2</sub>,…,<em>P</em><sub><em>n</em></sub>)</span></li>
<li>若 <span class="math inline"><em>A</em> ⇔ <em>B</em></span>，则
<span
class="math inline"><em>A</em><sup>*</sup> ⇔ <em>B</em><sup>*</sup></span></li>
</ol>
<p>范式：析取范式、合取范式、主析取范式、主合取范式</p>
<p>命题的可满足性：如果一个命题存在一个赋值为真，一个复合命题是可满足的（相容），不存在就是不可满足的（不相容）。</p>
<h3 id="谓词逻辑">1.2 谓词逻辑</h3>
<blockquote>
<p>命题函数、谓词、量词（全称、存在、唯一性）、论域、约束论域、量化表达式的否定</p>
</blockquote>
<p>量词的德·摩根律： <span
class="math display">¬∀<em>x</em><em>P</em>(<em>x</em>) ≡ ∃<em>x</em>¬<em>P</em>(<em>x</em>)</span></p>
<p><span
class="math display">¬∃<em>x</em><em>Q</em>(<em>x</em>) ≡ ∀<em>x</em>¬<em>Q</em>(<em>x</em>)</span></p>
<p>语句到逻辑表达式的翻译：定义命题函数、定义论域、给出逻辑表达式</p>
<h3 id="嵌套量词">1.4 嵌套量词</h3>
<p>嵌套量词即出现在其他量词的作用域中的量词，比如：<span
class="math inline">∀<em>x</em>∃<em>y</em>(<em>x</em>+<em>y</em>=0)</span>。</p>
<p>量词的顺序会对量化式的含义造成影响，但如果全是全称或存在量词，那就没有影响。</p>
<p><span
class="math inline">∃<em>y</em>∀<em>x</em><em>Q</em>(<em>x</em>,<em>y</em>)</span>
为真，则 <span
class="math inline">∀<em>x</em>∃<em>y</em><em>Q</em>(<em>x</em>,<em>y</em>)</span>
为真，但反过来不一定。</p>
<p>会翻译和使用含有嵌套量词的量化式。</p>
<p>嵌套量词的否定：可以通过将否定词按否定规则（量词的德摩根律）依次移入所有量词里来得到。</p>
<h3 id="推理规则">1.5 推理规则</h3>
<h4 id="命题逻辑的推理规则">1.5.1 命题逻辑的推理规则</h4>
<p>证明一个命题正确的方法：</p>
<ol type="1">
<li>真值表法</li>
<li>等价演算法</li>
<li>演绎推理法：P 规则、E 规则、T 规则</li>
<li>附加前提法（有两种，第二种也叫 CP 规则）：
<ol type="1">
<li>当要证明 <span class="math inline"><em>A</em> ⇒ <em>B</em></span>
时，即证明 <span
class="math inline"><em>A</em>, ¬<em>B</em> ⇒ 0</span>，也就是将结论否定，加入前提，证明其为矛盾式。</li>
<li>要证明当 <span class="math inline"><em>A</em></span> 成立时，从
<span class="math inline"><em>B</em></span> 能推出 <span
class="math inline"><em>C</em></span>，即 <span
class="math inline"><em>A</em> ⇒ <em>B</em> → <em>C</em></span>，可以转换为证明当
<span class="math inline"><em>A</em>、<em>B</em></span> 都成立时，<span
class="math inline"><em>C</em></span> 成立，即 <span
class="math inline"><em>A</em>, <em>B</em> ⇒ <em>C</em></span>，话句话说，就是将结论中的一部分拿出来当作前提。</li>
</ol></li>
</ol>
<p>假言推理（分离规则）：<span
class="math inline">(<em>p</em>∧(<em>p</em>→<em>q</em>)) → <em>q</em></span>。这是一个永真式，它是假言推理的基础。</p>
<p>假言三段论（递推）、附加律（<span
class="math inline"><em>p</em> → <em>p</em> ∨ <em>q</em></span>）、化简律（<span
class="math inline"><em>p</em> ∧ <em>q</em> → <em>p</em></span>）、取拒式（若
<span class="math inline"><em>p</em> → <em>q</em></span> 且 <span
class="math inline">¬<em>q</em></span>，则 <span
class="math inline">¬<em>p</em></span>）、析取三段论（若 <span
class="math inline"><em>p</em> ∨ <em>q</em></span> 且 <span
class="math inline">¬<em>p</em></span>，则 <span
class="math inline"><em>q</em></span>）、消解律（p发生或者q发生，p不发生或者r发生，这两个前提恒成立，则q和r中至少有一个发生）</p>
<h4 id="量化命题的推理规则">1.5.2 量化命题的推理规则</h4>
<ol type="1">
<li>全称实例（UI规则）：若 <span
class="math inline">∀<em>x</em><em>P</em>(<em>x</em>)</span> 成立且
<span class="math inline"><em>c</em></span> 是该论域内的一个元素，则
<span class="math inline"><em>P</em>(<em>c</em>)</span> 成立。</li>
<li>全称引入（UG规则）：若对某一论域内的任意 <span
class="math inline"><em>c</em></span>，<span
class="math inline"><em>P</em>(<em>c</em>)</span> 均成立，则 <span
class="math inline">∀<em>x</em><em>P</em>(<em>x</em>)</span> 成立。</li>
<li>存在实例（EI规则）：若 <span
class="math inline">∃<em>x</em><em>P</em>(<em>x</em>)</span> 成立且
<span class="math inline"><em>c</em></span>
是该论域内满足要求的一个元素，则 <span
class="math inline"><em>P</em>(<em>c</em>)</span> 成立。</li>
<li>存在引入（EG规则）：若某一论域内的某个 <span
class="math inline"><em>c</em></span> 使 <span
class="math inline"><em>P</em>(<em>c</em>)</span> 成立，则 <span
class="math inline">∃<em>x</em><em>P</em>(<em>x</em>)</span> 成立。</li>
</ol>
<h4 id="间接证明">1.5.3 间接证明</h4>
<p>反证法是一种重要的间接证明方式：要证明 <span
class="math inline"><em>s</em> → <em>c</em></span>
是永真式，即证明其逆否命题 <span
class="math inline">¬<em>c</em> → ¬<em>s</em></span>
是永真式，其逆否命题也可以写做 <span
class="math inline"><em>c</em> ∨ ¬<em>s</em></span>，其否定形式就是
<span class="math inline">¬<em>c</em> ∧ <em>s</em></span>，若能证明
<span class="math inline">¬<em>c</em> ∧ <em>s</em></span>
为矛盾式，则证明 <span
class="math inline"><em>s</em> → <em>c</em></span> 为永真式。</p>
<h2 id="集合函数基数矩阵">02 集合、函数、基数、矩阵</h2>
<h3 id="集合">2.1 集合</h3>
<p>定义集合的方法：</p>
<ol type="1">
<li>花名册法：列出集合中全部的元素</li>
<li>集合构造器：通过描述成员的性质来构造集合</li>
<li>文氏图</li>
</ol>
<blockquote>
<p>注意：空集表示为 <span class="math inline">{}</span> 或 <span
class="math inline">∅</span>，但 <span class="math inline">{∅}</span>
不是空集！</p>
</blockquote>
<p>两个集合相等：当且仅当两个集合 <span
class="math inline"><em>A</em></span> 和 <span
class="math inline"><em>B</em></span> 中的元素都相等时，<span
class="math inline"><em>A</em></span> 和 <span
class="math inline"><em>B</em></span> 相等，即 <span
class="math inline">∀<em>x</em>(<em>x</em>∈<em>A</em>↔︎<em>x</em>∈<em>B</em>)</span>。</p>
<h4 id="子集">2.1.1 子集</h4>
<ol type="1">
<li>A 是 B 的子集写做 <span
class="math inline"><em>A</em> ⊆ <em>B</em></span>，当且仅当 <span
class="math inline">∀<em>x</em>(<em>x</em>∈<em>A</em>→<em>x</em>∈<em>B</em>)</span>
成立</li>
<li>空集是任何集合的子集，一个集合本身是子集的子集</li>
<li>A 是 B 的真子集写做 <span
class="math inline"><em>A</em> ⊊ <em>B</em></span>，当且仅当 <span
class="math inline">∀<em>x</em>(<em>x</em>∈<em>A</em>→<em>x</em>∈<em>B</em>) ∧ ∃<em>x</em>(<em>x</em>∈<em>B</em>∧<em>x</em>∉<em>A</em>)</span>
成立</li>
<li>基数：集合 <span class="math inline"><em>S</em></span>
中不重复元素的个数称为 <span class="math inline"><em>S</em></span>
的基数，记作 <span class="math inline">|<em>S</em>|</span></li>
<li><strong>幂集</strong>：<span class="math inline"><em>S</em></span>
的幂集是 <span class="math inline"><em>S</em></span>
所有子集构成的集合，记作 <span
class="math inline">𝒫(<em>S</em>)</span>，一个有 <span
class="math inline"><em>n</em></span> 个元素的集合的幂集的基数为 <span
class="math inline">2<sup><em>n</em></sup></span>（注意：幂集中包括一个空集
<span class="math inline">∅</span>）</li>
</ol>
<h4 id="笛卡尔积">2.1.2 笛卡尔积</h4>
<ol type="1">
<li>有序 n 元组</li>
<li>笛卡尔积：集合 <span class="math inline"><em>A</em></span> 和 <span
class="math inline"><em>B</em></span> 的笛卡尔积用 <span
class="math inline"><em>A</em> × <em>B</em></span> 来表示，定义为 <span
class="math inline"><em>A</em> × <em>B</em> = {(<em>a</em>,<em>b</em>)|<em>a</em> ∈ <em>A</em> ∧ <em>b</em> ∈ <em>B</em>}</span>，其中
(a,b) 称为序偶</li>
<li><span class="math inline"><em>n</em></span> 个集合的笛卡尔积：<span
class="math inline"><em>A</em><sub>1</sub> × <em>A</em><sub>2</sub> × … × <em>A</em><sub><em>n</em></sub> = {(<em>a</em><sub>1</sub>,<em>a</em><sub>2</sub>,…,<em>a</em><sub><em>n</em></sub>)|<em>a</em><sub><em>i</em></sub> ∈ <em>A</em><sub><em>i</em></sub>, <em>f</em><em>o</em><em>r</em> <em>i</em> = 1, 2, …, <em>n</em>}</span></li>
</ol>
<h4 id="真值集">2.1.3 真值集</h4>
<p>给定谓词 <span class="math inline"><em>P</em></span> 和论域 <span
class="math inline"><em>D</em></span>，定义 <span
class="math inline"><em>P</em></span> 的真值集为 <span
class="math inline"><em>D</em></span> 中使 <span
class="math inline"><em>P</em>(<em>x</em>)</span> 为真的元素 <span
class="math inline"><em>x</em></span> 组成的集合。</p>
<p><span class="math inline"><em>P</em>(<em>x</em>)</span> 的真值集记为
<span
class="math inline">{<em>x</em> ∈ <em>D</em>|<em>P</em>(<em>x</em>)}</span>。</p>
<p>当且仅当 <span class="math inline"><em>P</em></span> 的真值集为 <span
class="math inline"><em>U</em></span> 时，<span
class="math inline">∀<em>x</em><em>P</em>(<em>x</em>)</span> 在论域
<span class="math inline"><em>U</em></span> 上为真。</p>
<p>当且仅当 <span class="math inline"><em>P</em></span>
的真值集非空时，<span
class="math inline">∃<em>x</em><em>P</em>(<em>x</em>)</span> 在论域
<span class="math inline"><em>U</em></span> 上为真。</p>
<h3 id="集合运算">2.2 集合运算</h3>
<h4 id="运算">2.2.1 运算</h4>
<ol type="1">
<li>并</li>
<li>交</li>
<li>不相交（交集为空）</li>
<li>容斥原理：<span
class="math inline">|<em>A</em>∪<em>B</em>| = |<em>A</em>| + |<em>B</em>| − |<em>A</em>∩<em>B</em>|</span></li>
<li>差</li>
<li>补：令 <span class="math inline"><em>A</em></span> 的全集为 <span
class="math inline"><em>U</em></span>，则 <span
class="math inline"><em>A</em></span> 关于 <span
class="math inline"><em>U</em></span> 的补集为 <span
class="math inline">$\overline A=U-A$</span>，也可记作 <span
class="math inline"> ∼ <em>A</em></span></li>
<li>对称差：<span class="math inline"><em>A</em></span> 和 <span
class="math inline"><em>B</em></span> 的对称差是指 <span
class="math inline"><em>A</em></span> 和 <span
class="math inline"><em>B</em></span>
含有的但并不共同含有的元素构成的集合，记作 <span
class="math inline"><em>A</em> ⊕ <em>B</em> = (<em>A</em>−<em>B</em>) ∪ (<em>B</em>−<em>A</em>)</span></li>
</ol>
<h4 id="集合恒等式">2.2.2 集合恒等式</h4>
<p>重点关注分配律、德摩根律、吸收律、互补律</p>
<p>证明集合相等：</p>
<ol type="1">
<li>证明集合互为对方的子集；</li>
<li>使用集合构造器和逻辑等价式；</li>
<li>使用成员表（可以把 <span class="math inline">∪</span> 和 <span
class="math inline">∩</span> 分别看作 <span class="math inline">∨</span>
和 <span class="math inline">∧</span>，然后就直接构造真值表）；</li>
<li>使用集合恒等式推导。</li>
</ol>
<h3 id="函数">2.3 函数</h3>
<p>定义域、陪域、值域、像、原像</p>
<p>定义：<span
class="math inline">(<em>f</em><sub>1</sub>+<em>f</em><sub>2</sub>)(<em>x</em>) = <em>f</em><sub>1</sub>(<em>x</em>) + <em>f</em><sub>2</sub>(<em>x</em>)</span>、<span
class="math inline"><em>f</em><sub>1</sub><em>f</em><sub>2</sub>(<em>x</em>) = <em>f</em><sub>1</sub>(<em>x</em>)<em>f</em><sub>2</sub>(<em>x</em>)</span></p>
<p>单射(一对一)函数：满足一对一关系的函数，严格单调递增和严格单调递减的函数一定是单射函数。</p>
<p>映上(满射)函数：陪域中的每一个元素都能对应到定义域中的一个元素，称为映上函数（也可以理解为陪域和值域相等）。</p>
<p>双射(一一对应)函数：一个函数既是单射函数又是满射函数，则称为双射函数。</p>
<p>恒等函数：<span
class="math inline"><em>f</em>(<em>x</em>) = <em>x</em></span></p>
<p>反函数：只有单射函数和映上函数才有反函数。</p>
<p>复合函数：<span
class="math inline">(<em>f</em>◦<em>g</em>)(<em>a</em>) = <em>f</em>(<em>g</em>(<em>a</em>))</span></p>
<h3 id="基数">2.4 基数</h3>
<p>当且仅当存在一个<strong>单射函数</strong> <span
class="math inline"><em>f</em></span> 使得 <span
class="math inline"><em>f</em>(<em>A</em>) = <em>B</em></span> 时，集合
<span class="math inline"><em>A</em></span> 和集合 <span
class="math inline"><em>B</em></span> 有相同的基数。</p>
<p>如果一个无限集 <span class="math inline"><em>S</em></span>
是可数（可数是指能枚举）的，那我们就称 <span
class="math inline"><em>S</em></span> 有基数 <span
class="math inline">ℵ<sub>0</sub></span>（阿里夫零）。</p>
<p>可数集的子集（无论是有限子集还是无限子集）当然也是可数集。</p>
<p>一个集合的子集不可数，则该集合也不可数。</p>
<p>如果存在单射函数 <span class="math inline"><em>f</em></span> 将 <span
class="math inline"><em>A</em></span> 映射到 <span
class="math inline"><em>B</em></span>，还存在单射函数 <span
class="math inline"><em>g</em></span> 将 <span
class="math inline"><em>B</em></span> 映射到 <span
class="math inline"><em>A</em></span>，则 <span
class="math inline">|<em>A</em>| = |<em>B</em>|</span>，即 <span
class="math inline"><em>A</em></span> 与 <span
class="math inline"><em>B</em></span>
之间存在一一对应关系（双射函数）。</p>
<h3 id="矩阵">2.5 矩阵</h3>
<p>唯一陌生的点：布尔积（⊙）、布尔积的幂（<span
class="math inline"><em>A</em><sup>[<em>p</em>]</sup></span>）</p>
<h2 id="计数">03 计数</h2>
<h3 id="鸽巢原理">3.1 鸽巢原理</h3>
<p>陈述：k + 1 只鸽子要飞往 k 个鸽巢，则有一个鸽巢至少有 2 只鸽子。</p>
<p>推论 1：一个从 <span class="math inline"><em>k</em> + 1</span>
个甚至更多元素到 <span class="math inline"><em>k</em></span>
个元素的集合的映射 <span class="math inline"><em>f</em></span>
一定不是单射函数。</p>
<p>广义鸽巢原理：如果 N 个物体放入 k
个盒子，那么至少有一个盒子包含了至少 <span
class="math inline">⌈<em>N</em>/<em>k</em>⌉</span> 个物体。</p>
<p>定理：每个由 <span
class="math inline"><em>n</em><sup>2</sup> + 1</span>
个不同实数构成的序列都包含一个长为 <span
class="math inline"><em>n</em> + 1</span>
的严格递增子序列或严格递减子序列。</p>
<p>拉姆齐数：<span
class="math inline"><em>R</em>(<em>m</em>,<em>n</em>)</span>，表示一个舞会上，使得或者
<span class="math inline"><em>m</em></span> 个人两两是朋友，或者 <span
class="math inline"><em>n</em></span> 个人两两是敌人的最少人数。</p>
<h3 id="排列组合">3.2 排列组合</h3>
<p><span class="math inline"><em>r</em></span> 排列： 对一个集合中 <span
class="math inline"><em>r</em></span> 个元素的有序排列称为 <span
class="math inline"><em>r</em></span> 排列。</p>
<p>具有 <span class="math inline"><em>n</em></span> 个不同元素的集合的
<span class="math inline"><em>r</em></span> 排列数是 <span
class="math inline">$P(n,r)=n(n-1)(n-2)\dots(n-r+1)=\frac{n!}{(n-r)!}$</span>。</p>
<p><span class="math inline"><em>r</em></span> 组合： 对一个集合中 <span
class="math inline"><em>r</em></span> 个元素的无序排列称为 <span
class="math inline"><em>r</em></span> 组合。</p>
<p>具有 <span class="math inline"><em>n</em></span> 个不同元素的集合的
<span class="math inline"><em>r</em></span> 组合数是 <span
class="math inline">$C(n,r)=\frac{n!}{r!(n-r)!}$</span>，组合数的性质
<span
class="math inline"><em>C</em>(<em>n</em>,<em>r</em>) = <em>C</em>(<em>n</em>,<em>n</em>−<em>r</em>)</span>。</p>
<p>二项式定理： <span class="math display">$$
(x+y)^n=\sum_{j=0}^{n}C(n,j)x^{n-j}y^j
$$</span> 推论：设 <span class="math inline"><em>n</em></span>
为非负整数，令 <span class="math inline"><em>x</em> = 1</span> 和 <span
class="math inline"><em>y</em> = 1</span>，我们有 <span
class="math display">$$
\sum_{k=0}^{n}C(n,k)=2^n
$$</span></p>
<p><span class="math display">$$
\sum_{k=0}^{n}(-1)^kC(n,k)=0
$$</span></p>
<p><span class="math display">$$
\sum_{k=0}^{n}2^kC(n,k)=3^n
$$</span></p>
<p>帕斯卡恒等式： <span
class="math display"><em>C</em><sub><em>k</em></sub><sup><em>n</em> + 1</sup> = <em>C</em><sub><em>k</em> − 1</sub><sup><em>n</em></sup> + <em>C</em><sub><em>k</em></sub><sup><em>n</em></sup></span>
范德蒙德恒等式： <span class="math display">$$
C_{r}^{m+n}=\sum_{k=0}^{r}C_{r-k}^mC^n_k
$$</span> 推论4：如果 n 是一个非负整数，那么 <span
class="math display">$$
C_n^{2n}=\sum_{k=0}^{n}(C_{k}^{n})^2
$$</span> 定理4：设 n 和 r 是非负整数，且有 <span
class="math inline"><em>r</em> ≤ <em>n</em></span>，那么 <span
class="math display">$$
C_{r+1}^{n+1}=\sum_{j=r}^{n}C_{r}^{j}
$$</span></p>
<h3 id="排列组合的推广">3.3 排列组合的推广</h3>
<p>定理1：具有n个对象的集合允许重复的r排列数为<span
class="math inline"><em>n</em><sup><em>r</em></sup></span>。</p>
<p>定理2：具有n个对象的集合允许重复的r组合数为<span
class="math inline"><em>C</em>(<em>n</em>+<em>r</em>−1,<em>r</em>)</span>。</p>
<p>具有不可区别物体的集合的排列：类型1的相同的物体有<span
class="math inline"><em>n</em><sub>1</sub></span>个，类型2的相同的物体有<span
class="math inline"><em>n</em><sub>2</sub></span>个，……，类型k的相同的物体有<span
class="math inline"><em>n</em><sub><em>k</em></sub></span>个，那么<span
class="math inline"><em>n</em></span>个物体的不同排列数是<span
class="math inline">$\frac{n!}{n_1!n_2!\dots n_k!}$</span>。</p>
<p>把物体放入盒子：将<span
class="math inline"><em>n</em></span>个不同的物体分配到<span
class="math inline"><em>k</em></span>个不同的盒子使得<span
class="math inline"><em>n</em><sub><em>i</em></sub></span>个物体放入第<span
class="math inline"><em>i</em></span>（<span
class="math inline"><em>i</em> = 1, 2, ..., <em>k</em></span>）个盒子的方式数为<span
class="math inline">$\frac{n!}{n_1!n_2!\dots n_k!}$</span>。</p>
<h2 id="求解线性递推关系式">04 求解线性递推关系式</h2>
<p>所谓求解线性递推关系式（linear recurrence
relation），其实就是高中数列的通项公式求解。</p>
<h3 id="线性常系数齐次递推关系式">4.1 线性常系数齐次递推关系式</h3>
<p>一个常系数 <span class="math inline"><em>k</em></span>
阶线性齐次递推关系是形如 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>c</em><sub>1</sub><em>a</em><sub><em>n</em> − 1</sub> + <em>c</em><sub>2</sub><em>a</em><sub><em>n</em> − 2</sub> + … + <em>c</em><sub><em>k</em></sub><em>a</em><sub><em>n</em> − <em>k</em></sub></span>
的递推关系，其中 <span
class="math inline"><em>c</em><sub>1</sub>, <em>c</em><sub>2</sub>, …, <em>c</em><sub><em>k</em></sub></span>
为实数，且 <span
class="math inline"><em>c</em><sub><em>k</em></sub> ≠ 0</span>（若 <span
class="math inline"><em>c</em><sub><em>k</em></sub></span> 为 <span
class="math inline">0</span> 的话就不是 <span
class="math inline"><em>k</em></span> 阶了）。</p>
<p>求解线性常系数齐次递推关系式：</p>
<p><strong>基本方法</strong>是寻找形如 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>r</em><sup><em>n</em></sup></span>
的解，其中 <span class="math inline"><em>r</em></span>
是常数，代入到递推关系式就有： <span
class="math display"><em>r</em><sup><em>n</em></sup> = <em>c</em><sub>1</sub><em>r</em><sup><em>n</em> − 1</sup> + <em>c</em><sub>2</sub><em>r</em><sup><em>n</em> − 2</sup> + … + <em>c</em><sub><em>k</em></sub><em>r</em><sup><em>n</em> − <em>k</em></sup></span>
等式两边同时除以 <span
class="math inline"><em>r</em><sup><em>n</em> − <em>k</em></sup></span>，移项得到<strong>特征方程</strong>：
<span
class="math display"><em>r</em><sup><em>k</em></sup> − <em>c</em><sub>1</sub><em>r</em><sup><em>k</em> − 1</sup> − <em>c</em><sub>2</sub><em>r</em><sup><em>k</em> − 2</sup> − … − <em>c</em><sub><em>k</em> − 1</sub><em>r</em> − <em>c</em><sub><em>k</em></sub> = 0</span>
当且仅当 <span class="math inline"><em>r</em></span>
是特征方程的解时，具有 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>r</em><sup><em>n</em></sup></span>
的序列 <span
class="math inline">{<em>a</em><sub><em>n</em></sub>}</span>
是一个解。特征方程的解称为递推关系的特征根，可用特根给出递推关系的所有解的显式表达式。</p>
<blockquote>
<p>特征方程其实就是一个一元 <span class="math inline"><em>k</em></span>
次方程，可证明的是，当 <span class="math inline"><em>k</em> ≥ 5</span>
时，方程没有解析解。</p>
</blockquote>
<h4 id="单根">4.1.1 单根</h4>
<p>定理 1：若特征方程 <span
class="math inline"><em>r</em><sup>2</sup> − <em>c</em><sub>1</sub><em>r</em> − <em>c</em><sub>2</sub> = 0</span>
有两个不相等的根 <span
class="math inline"><em>r</em><sub>1</sub></span>、<span
class="math inline"><em>r</em><sub>2</sub></span>，当且仅当 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>α</em><sub>1</sub><em>r</em><sub>1</sub><sup><em>n</em></sup> + <em>α</em><sub>2</sub><em>r</em><sub>2</sub><sup><em>n</em></sup></span>
时，<span class="math inline">{<em>a</em><sub><em>n</em></sub>}</span>
就是递推关系式 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>c</em><sub>1</sub><em>a</em><sub><em>n</em> − 1</sub> + <em>c</em><sub>2</sub><em>a</em><sub><em>n</em> − 2</sub></span>
的解。（其中 <span class="math inline"><em>α</em><sub>1</sub></span> 和
<span class="math inline"><em>α</em><sub>2</sub></span>
可以靠初始条件得到）</p>
<h4 id="重根">4.1.2 重根</h4>
<p>定理 2：若特征方程 <span
class="math inline"><em>r</em><sup>2</sup> − <em>c</em><sub>1</sub><em>r</em> − <em>c</em><sub>2</sub> = 0</span>
有一个重根 <span
class="math inline"><em>r</em><sub>0</sub></span>，当且仅当 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>α</em><sub>1</sub><em>r</em><sub>0</sub><sup><em>n</em></sup> + <em>α</em><sub>2</sub><em>n</em><em>r</em><sub>0</sub><sup><em>n</em></sup></span>
时，<span class="math inline">{<em>a</em><sub><em>n</em></sub>}</span>
就是递推关系式 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>c</em><sub>1</sub><em>a</em><sub><em>n</em> − 1</sub> + <em>c</em><sub>2</sub><em>a</em><sub><em>n</em> − 2</sub></span>
的解。（其中 <span class="math inline"><em>α</em><sub>1</sub></span> 和
<span class="math inline"><em>α</em><sub>2</sub></span>
可以靠初始条件得到）</p>
<h4 id="任意阶">4.1.3 任意阶</h4>
<p>定理 3：若特征方程 <span
class="math inline"><em>r</em><sup><em>k</em></sup> − <em>c</em><sub>1</sub><em>r</em><sup><em>k</em> − 1</sup> − … − <em>c</em><sub><em>k</em></sub> = 0</span>
有 <span class="math inline"><em>k</em></span> 个不相等的根 <span
class="math inline"><em>r</em><sub>1</sub>、<em>r</em><sub>2</sub>、…、<em>r</em><sub><em>k</em></sub></span>，当且仅当
<span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>α</em><sub>1</sub><em>r</em><sub>1</sub><sup><em>n</em></sup> + <em>α</em><sub>2</sub><em>r</em><sub>2</sub><sup><em>n</em></sup> + … + <em>α</em><sub><em>k</em></sub><em>r</em><sub><em>k</em></sub><sup><em>n</em></sup></span>
时，<span class="math inline">{<em>a</em><sub><em>n</em></sub>}</span>
就是递推关系式 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>c</em><sub>1</sub><em>a</em><sub><em>n</em> − 1</sub> + <em>c</em><sub>2</sub><em>a</em><sub><em>n</em> − 2</sub> + … + <em>c</em><sub><em>k</em></sub><em>a</em><sub><em>n</em> − <em>k</em></sub></span>
的解。</p>
<h4 id="部分重根">4.1.4 部分重根</h4>
<p>定理 4：假设特征方程 <span
class="math inline"><em>r</em><sup><em>k</em></sup> − <em>c</em><sub>1</sub><em>r</em><sup><em>k</em> − 1</sup> − … − <em>c</em><sub><em>k</em></sub> = 0</span>
有 <span class="math inline"><em>t</em></span>
个不同的根，每个根的重数分别为 <span
class="math inline"><em>m</em><sub>1</sub>, <em>m</em><sub>2</sub>, …, <em>m</em><sub><em>t</em></sub></span>，则解为
<span class="math display">$$
a_n=\sum_{i=1}^{t}(\sum_{j=1}^{m_t}\alpha_{t,j}n^{j-1})r_t^n
$$</span></p>
<h3 id="线性常系数非齐次递推关系式">4.2 线性常系数非齐次递推关系式</h3>
<p>形如 <span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>c</em><sub>1</sub><em>a</em><sub><em>n</em> − 1</sub> + <em>c</em><sub>2</sub><em>a</em><sub><em>n</em> − 2</sub> + … + <em>c</em><sub><em>k</em></sub><em>a</em><sub><em>n</em> − <em>k</em></sub> + <em>F</em>(<em>n</em>)</span>
的递推式就是线性常系数非齐次递推关系式，其中 <span
class="math inline"><em>F</em>(<em>n</em>)</span> 是一个只依赖与 <span
class="math inline"><em>n</em></span> 且不等于零的函数。其中，<span
class="math inline"><em>a</em><sub><em>n</em></sub> = <em>c</em><sub>1</sub><em>a</em><sub><em>n</em> − 1</sub> + <em>c</em><sub>2</sub><em>a</em><sub><em>n</em> − 2</sub> + … + <em>c</em><sub><em>k</em></sub><em>a</em><sub><em>n</em> − <em>k</em></sub></span>
叫做相伴的线性齐次递推关系。</p>
<p>类似于线性代数中的特解+通解，线性常系数非齐次递推关系式的每个解，都是一个特解和相伴线性齐次递推关系的一个解的和。</p>
<p>求线性常系数非齐次递推关系式的通解：</p>
<ol type="1">
<li>先求相伴的线性齐次递推关系的解</li>
<li>根据 <span class="math inline"><em>F</em>(<em>n</em>)</span>
的形式，设出一个特解形式，将特解代回通项公式中解出该特解</li>
<li>将两个解加起来就是通解</li>
</ol>
<p>将初始条件带入通解，得到一个特解。</p>
<p>下面的定理给出了特解形式的设法：</p>
<blockquote>
<p>若一个非齐次递推关系式中的非齐次项 <span
class="math inline"><em>F</em>(<em>n</em>)</span> 有如下形式： <span
class="math display"><em>F</em>(<em>n</em>) = (<em>b</em><sub><em>t</em></sub><em>n</em><sup><em>t</em></sup>+<em>b</em><sub><em>t</em> − 1</sub><em>n</em><sup><em>t</em> − 1</sup>+…+<em>b</em><sub>0</sub>)<em>s</em><sup><em>n</em></sup></span>
若其中 <span class="math inline"><em>s</em></span>
不是相伴齐次递推关系的特征方程的根，存在一个下述形式的特解： <span
class="math display">(<em>p</em><sub><em>t</em></sub><em>n</em><sup><em>t</em></sup>+<em>p</em><sub><em>t</em> − 1</sub><em>n</em><sup><em>t</em> − 1</sup>+…+<em>p</em><sub>0</sub>)<em>s</em><sup><em>n</em></sup></span>
若其中 <span class="math inline"><em>s</em></span>
是相伴齐次递推关系的特征方程的 <span
class="math inline"><em>m</em></span> 重根，存在一个下述形式的特解：
<span
class="math display"><em>n</em><sup><em>m</em></sup>(<em>p</em><sub><em>t</em></sub><em>n</em><sup><em>t</em></sup>+<em>p</em><sub><em>t</em> − 1</sub><em>n</em><sup><em>t</em> − 1</sup>+…+<em>p</em><sub>0</sub>)<em>s</em><sup><em>n</em></sup></span></p>
</blockquote>
<h2 id="容斥原理">05 容斥原理</h2>
<p>基本的容斥： <span
class="math display">|<em>A</em>∪<em>B</em>| = |<em>A</em>| + |<em>B</em>| − |<em>A</em>∩<em>B</em>|</span>
三个有限集： <span
class="math display">|<em>A</em>∪<em>B</em>∪<em>C</em>| = |<em>A</em>| + |<em>B</em>| + |<em>C</em>| − |<em>A</em>∩<em>B</em>| − |<em>B</em>∩<em>C</em>| − |<em>A</em>∩<em>C</em>| + |<em>A</em>∩<em>B</em>∩<em>C</em>|</span>
推广到 <span class="math inline"><em>n</em></span> 个有限集： <span
class="math display">$$
\begin{aligned}
|A_1\cup A_2\cup\dots\cup A_n|=&amp;\sum_{i\le i\le
n}|A_i|\\&amp;-\sum_{1\le i\le j\le n}|A_i\cap A_j|\\&amp;+\sum_{1\le
i\le j\le k\le n}|A_i\cap A_j\cap
A_k|\\&amp;-\dots\\&amp;+(-1)^{n+1}|A_1\cap A_2\cap\dots\cap A_n|
\end{aligned}
$$</span></p>
<h3 id="错位排列">5.1 错位排列</h3>
<p><span class="math inline"><em>n</em></span>
个元素的集合的错位排列数为 <span class="math display">$$
D_n=n![1-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+\dots+(-1)^n\frac{1}{n!}]
$$</span></p>
<h3 id="埃拉托色尼筛伊拉脱森筛">5.2 埃拉托色尼筛(伊拉脱森筛)</h3>
<p>埃拉托色尼筛是一种找出一定范围内所有素数的算法。</p>
<p>其原理很简单：假设要求出 100 以内所有素数，则先列出 2-100
范围内所有的整数，执行下面的步骤：</p>
<ol type="1">
<li>选出序列中未被标记的第一个数，将其之后所有倍数都进行标记；</li>
<li>重复步骤 1，直到找不到未被标记的数为止（要跳过步骤 1
选取的数）；</li>
<li>剩余序列中未被标记的元素就是 100 以内所有的素数。</li>
</ol>
<p>时间复杂度为 <span
class="math inline"><em>O</em>(<em>n</em>loglog<em>n</em>)</span>。</p>
<p>埃拉托色尼筛的本质是一种容斥，基于不超过 100 的合数肯定有一个不超过
10 的素因子，因此选出 10 以内所有的素因子有 2、3、5、7，令 <span
class="math inline"><em>P</em><sub>1</sub></span> 表示能被 2
整除的性质，<span class="math inline"><em>P</em><sub>2</sub></span>
表示能被 3 整除的性质，<span
class="math inline"><em>P</em><sub>3</sub></span> 表示能被 5
整除的性质，<span class="math inline"><em>P</em><sub>4</sub></span>
表示能被 7 整除的性质，则不超过 100 的素数的个数就是 <span
class="math inline"><em>N</em>(<em>P</em><sub>1</sub><sup>′</sup><em>P</em><sub>2</sub><sup>′</sup><em>P</em><sub>3</sub><sup>′</sup><em>P</em><sub>4</sub><sup>′</sup>)</span>，然后应用容斥原理就可以求了。</p>
<h2 id="关系">06 关系</h2>
<h3 id="二元关系">6.1 二元关系</h3>
<p>由有序对构成的集合称为一个关系，例如（1,b）。一个关系表示一个集合
<span class="math inline"><em>A</em></span> 到另一个集合 <span
class="math inline"><em>B</em></span> 的映射，若存在 <span
class="math inline">1 ∈ <em>A</em></span>，<span
class="math inline"><em>b</em> ∈ <em>B</em></span>，且有关系 <span
class="math inline">(1,<em>b</em>)</span>，则写做 <span
class="math inline">1<em>R</em><em>b</em></span>，否则在 R
标记上画一条斜对角线表示不存在这样的关系 <span
class="math inline">1<em>R</em≯<em>b</em></span>。</p>
<p>关系其实就是两个集合的笛卡尔积的子集。那么，含有 <span
class="math inline"><em>n</em></span> 个元素的集合 A
上最多有多少关系？其实就是考虑 <span
class="math inline"><em>A</em> × <em>A</em></span> 的子集个数，<span
class="math inline"><em>A</em> × <em>A</em></span> 有 <span
class="math inline"><em>n</em><sup>2</sup></span> 个元素，<span
class="math inline"><em>m</em></span> 个元素构成的集合有 <span
class="math inline">2<sup><em>m</em></sup></span> 个子集，所以 <span
class="math inline"><em>A</em> × <em>A</em></span> 有 <span
class="math inline">2<sup>|<em>A</em>|<sup>2</sup></sup></span>
个关系。</p>
<p>二元关系的记号：</p>
<ol type="1">
<li>前缀表示法：<span
class="math inline"><em>R</em>(<em>x</em>,<em>y</em>)</span></li>
<li>中缀表示法：<span
class="math inline"><em>x</em><em>R</em><em>y</em></span></li>
<li>后缀表示法：<span
class="math inline">(<em>x</em>,<em>y</em>) ∈ <em>R</em></span></li>
</ol>
<p>函数是一种关系，但关系不一定是函数，因为关系可以一对多。</p>
<h4 id="性质">6.1.1 性质</h4>
<p>若对于 <span class="math inline"><em>A</em></span> 中每个元素 <span
class="math inline"><em>a</em></span>，都存在 <span
class="math inline">(<em>a</em>,<em>a</em>) ∈ <em>R</em></span>，则称
<span class="math inline"><em>R</em></span>
是自反的。如果这样的有序对一个都不存在，那就称 <span
class="math inline"><em>R</em></span>
是反自反的。（空关系既是自反的又是反自反的）</p>
<p>若对任意 <span
class="math inline">(<em>a</em>,<em>b</em>) ∈ <em>R</em></span> 都有
<span
class="math inline">(<em>b</em>,<em>a</em>) ∈ <em>R</em></span>，则称
<span class="math inline"><em>R</em></span> 是对称的。如果 <span
class="math inline">(<em>a</em>,<em>b</em>) ∈ <em>R</em></span> 并且
<span
class="math inline">(<em>b</em>,<em>a</em>) ∈ <em>R</em></span>，则有
<span class="math inline"><em>a</em> = <em>b</em></span>，则称 <span
class="math inline"><em>R</em></span>
是反对称的。（恒等关系既是对称的又是反对称的）</p>
<p>若对 <span
class="math inline">(<em>a</em>,<em>b</em>) ∈ <em>R</em></span> 和 <span
class="math inline">(<em>b</em>,<em>c</em>) ∈ <em>R</em></span>，都存在
<span
class="math inline">(<em>a</em>,<em>c</em>) ∈ <em>R</em></span>，则称
<span class="math inline"><em>R</em></span> 是传递的。</p>
<h4 id="关系的合成">6.1.2 关系的合成</h4>
<p>假设 <span class="math inline"><em>R</em><sub>1</sub></span> 是集合
<span class="math inline"><em>A</em></span> 到集合 <span
class="math inline"><em>B</em></span> 的关系，<span
class="math inline"><em>R</em><sub>2</sub></span> 是集合 <span
class="math inline"><em>B</em></span> 到集合 <span
class="math inline"><em>C</em></span> 的关系，则 <span
class="math inline"><em>R</em><sub>1</sub></span> 和 <span
class="math inline"><em>R</em><sub>2</sub></span> 的合成是 <span
class="math inline"><em>A</em></span> 到 <span
class="math inline"><em>C</em></span> 的关系，记作 <span
class="math inline"><em>R</em><sub>1</sub> ∘ <em>R</em><sub>2</sub></span>。</p>
<p>关系的幂就是多个关系合成：<span
class="math inline"><em>R</em><sup><em>n</em> + 1</sup> = <em>R</em><sup><em>n</em></sup> ∘ <em>R</em></span>。</p>
<h4 id="逆关系">6.1.3 逆关系</h4>
<p>记作 <span
class="math inline"><em>R</em><sup>−1</sup> = {(<em>y</em>,<em>x</em>)|(<em>x</em>,<em>y</em>) ∈ <em>R</em>}</span>。</p>
<p>定理：<span
class="math inline">(<em>R</em><sub>1</sub>∘<em>R</em><sub>2</sub>)<sup>−1</sup> = <em>R</em><sub>2</sub><sup>−1</sup> ∘ <em>R</em><sub>1</sub><sup>−1</sup></span>。</p>
<h3 id="关系表示">6.2 关系表示</h3>
<h4 id="矩阵-1">6.2.1 矩阵</h4>
<ol type="1">
<li>自反关系的矩阵对角线元素都是 1。</li>
<li>对称关系的矩阵是对称矩阵。</li>
<li>反对称关系的矩阵对角线元素都是 1，并且 <span
class="math inline"><em>a</em><sub><em>i</em><em>j</em></sub></span> 在
<span class="math inline"><em>i</em> ≠ <em>j</em></span> 的情况下，若
<span
class="math inline"><em>a</em><sub><em>i</em><em>j</em></sub> = 1</span>，则
<span
class="math inline"><em>a</em><sub><em>j</em><em>i</em></sub> = 0</span>。</li>
<li>关系的交、并运算可以转换为矩阵的或、与运算。</li>
<li>关系的合成可以转换为矩阵的布尔积运算，布尔幂的表示要在幂次上加个方括号。</li>
</ol>
<h4 id="图">6.2.2 图</h4>
<ol type="1">
<li>自反关系的图中的每个结点都有一个指向自己的边。</li>
<li>对称关系的图中每条边都是双向边。</li>
<li>反对称关系的图中每条边都是单边。</li>
<li>传递关系的图中，若 <span class="math inline"><em>a</em></span> 与
<span class="math inline"><em>b</em></span> 有连线，且 <span
class="math inline"><em>b</em></span> 与 <span
class="math inline"><em>c</em></span> 有连线，则 <span
class="math inline"><em>a</em></span> 与 <span
class="math inline"><em>c</em></span> 也有连线。</li>
</ol>
<h3 id="关闭的闭包">6.3 关闭的闭包</h3>
<p>所谓闭包，就是指为了让关系满足某个我们所需要的性质（传递、自反、对称）而往其中添加外来关系的集合。</p>
<p>若某个关系 <span class="math inline"><em>R</em></span>
不满足自反关系，则我们用 <span
class="math inline"><em>r</em>(<em>R</em>)</span> 表示 <span
class="math inline"><em>R</em></span>
的一个自反闭包，该闭包有如下特点：</p>
<ol type="1">
<li><span class="math inline"><em>r</em>(<em>R</em>)</span>
是自反的</li>
<li><span
class="math inline"><em>R</em> ⊂ <em>r</em>(<em>R</em>)</span></li>
<li>在所有满足 1、2 的集合中，<span
class="math inline"><em>r</em>(<em>R</em>)</span> 是最小的</li>
</ol>
<p>同理还有传递闭包、对称闭包。</p>
<p>如果一个关系是对称（自反、对称）关系，则它本身就是自己的对称（自反、对称）闭包。</p>
<p>如果一个关系是另一个关系的子集，那么它的闭包也是另一个闭包的子集。</p>
<p>三种闭包的求法：</p>
<ol type="1">
<li>自反闭包：令 <span
class="math inline"><em>Δ</em> = {(<em>a</em>,<em>a</em>)|<em>a</em> ∈ <em>A</em>}</span>，则
<span class="math inline"><em>R</em></span> 的自反闭包就是 <span
class="math inline"><em>R</em> ∪ <em>Δ</em></span>。</li>
<li>对称闭包：<span
class="math inline"><em>R</em> ∪ <em>R</em><sup>−1</sup></span></li>
<li>传递闭包：<span
class="math inline"><em>R</em> ∪ <em>R</em><sup>2</sup> ∪ <em>R</em><sup>3</sup> ∪ …</span></li>
</ol>
<h3 id="路径">6.4 路径</h3>
<p>定理：<span class="math inline"><em>a</em></span> 和 <span
class="math inline"><em>b</em></span> 之间存在一条长度为 <span
class="math inline"><em>n</em></span> 的路径，当且仅当 <span
class="math inline">(<em>a</em>,<em>b</em>) ∈ <em>R</em><sup><em>n</em></sup></span>.</p>
<h3 id="传递闭包">6.5 传递闭包</h3>
<p>给出连通性闭包的定义： <span class="math display">$$
R^{*}=\bigcup_{n=1}^{\infty}R^{n}
$$</span> 可以证明，连通性闭包和传递闭包是等价的。</p>
<p>令 <span class="math inline"><em>M</em><sub><em>R</em></sub></span>
是定义在 <span class="math inline"><em>n</em></span> 个元素集合上的关系
<span class="math inline"><em>R</em></span> 的 <span
class="math inline">0 − 1</span> 矩阵，那么传递闭包 <span
class="math inline"><em>R</em><sup>*</sup></span> 的 <span
class="math inline">0 − 1</span> 矩阵是： <span
class="math display"><em>M</em><sub><em>R</em><sup>*</sup></sub> = <em>M</em><sub><em>R</em></sub> ∨ <em>M</em><sub><em>R</em></sub><sup>[2]</sup> ∨ <em>M</em><sub><em>R</em></sub><sup>[3]</sup> ∨ … ∨ <em>M</em><sub><em>R</em></sub><sup>[<em>n</em>]</sup></span>
如果使用算法实现，则计算一次矩阵的布尔积需要进行 <span
class="math inline"><em>n</em><sup>2</sup>(2<em>n</em>−1)</span>
次位运算，计算 <span class="math inline"><em>n</em></span>
个矩阵的布尔积则共需要 <span
class="math inline"><em>n</em><sup>2</sup>(2<em>n</em>−1)(<em>n</em>−1)</span>
次位运算，故算法的时间复杂度为 <span
class="math inline"><em>O</em>(<em>n</em><sup>4</sup>)</span>。</p>
<p>沃舍尔算法对这种朴素的计算方式进行了优化，使得只需要 <span
class="math inline">2<em>n</em><sup>3</sup></span>
次位运算就可以求出这个传递闭包。</p>
<h3 id="等价关系">6.6 等价关系</h3>
<p>定义
1：当一个关系同时是自反、对称、传递的，就称其为<strong>等价关系</strong>。（tip：由于等价关系是自反的，因此定义在集合
<span class="math inline"><em>A</em></span> 上的等价关系必然涵盖了集合
<span class="math inline"><em>A</em></span> 中全部元素）</p>
<p>定义 2：假设 <span
class="math inline"><em>a</em><em>R</em><em>b</em></span>，且 <span
class="math inline"><em>R</em></span> 是等价关系，则称 <span
class="math inline"><em>a</em></span> 与 <span
class="math inline"><em>b</em></span> 等价，记作 <span
class="math inline"><em>a</em> ∼ <em>b</em></span></p>
<p>定义 3：如果 <span class="math inline"><em>R</em></span> 是 <span
class="math inline"><em>S</em></span> 上的等价关系，且 <span
class="math inline"><em>a</em> ∈ <em>S</em></span>，则将 <span
class="math inline"><em>R</em></span> 中所有与 <span
class="math inline"><em>a</em></span> 有关联的元素 <span
class="math inline"><em>s</em></span> 构成的集合称为 <span
class="math inline"><em>a</em></span>
的<strong>等价类</strong>，可表示为 <span
class="math inline">[<em>a</em>]<sub><em>R</em></sub> = {<em>s</em>|(<em>a</em>,<em>s</em>) ∈ <em>S</em>}</span>，而
<span class="math inline"><em>s</em></span> 称为 <span
class="math inline"><em>a</em></span>
的<strong>代表元</strong>。（tip：由于自反性，元素 <span
class="math inline"><em>a</em></span> 的等价类中必定包括了 <span
class="math inline"><em>a</em></span>）</p>
<p>定理 1：若 <span class="math inline"><em>R</em></span> 是定义在集合
<span class="math inline"><em>A</em></span>
上的等价关系，则下面三种表示等价：</p>
<ol type="1">
<li><span class="math inline"><em>a</em><em>R</em><em>b</em></span></li>
<li><span class="math inline">[<em>a</em>] = [<em>b</em>]</span></li>
<li><span
class="math inline">[<em>a</em>] ∩ [<em>b</em>] ≠ ∅</span></li>
</ol>
<p>等价类可以<strong>划分集合</strong>：假设 <span
class="math inline"><em>R</em></span> 是定义在集合 <span
class="math inline"><em>A</em></span>
上的等价关系。等价类和等价类之间必不相交，并且所有等价类的并集就是等价于集合
<span class="math inline"><em>A</em></span>。（可以参考模 4
同余关系）</p>
<p>定理
2：从上面的讨论我们已经知道给定一个集合和在这个集合上定义的等价关系，我们可以构造该集合的一个划分；那么反过来，给定该集合的一个划分，我们也能找到这样一个等价关系，能划分该集合。</p>
<h3 id="偏序">6.7 偏序</h3>
<h4 id="基本概念">6.7.1 基本概念</h4>
<p>定义 1：如果定义在集合 <span class="math inline"><em>S</em></span>
上的关系 <span class="math inline"><em>R</em></span>
是自反、反对称、传递的，则称其为<strong>偏序</strong>。集合 <span
class="math inline"><em>S</em></span> 与定义在其上的偏序 <span
class="math inline"><em>R</em></span>
一起称为<strong>偏序集</strong>，用 <span
class="math inline">(<em>S</em>,<em>R</em>)</span> 表示。集合 <span
class="math inline"><em>S</em></span> 中的成员称为偏序集的元素。</p>
<p>通常使用 <span class="math inline">≼</span> 表示偏序关系，如果 <span
class="math inline">(<em>a</em>,<em>b</em>) ∈ <em>R</em></span> 则记作
<span class="math inline"><em>a</em> ≼ <em>b</em></span>，若 <span
class="math inline"><em>a</em> ≠ <em>b</em></span>，则记作 <span
class="math inline"><em>a</em> ≺ <em>b</em></span>，这说明 <span
class="math inline"><em>a</em></span> 和 <span
class="math inline"><em>b</em></span> 是可比的。</p>
<p>偏序集中的元素并不都是可比的，这句话的意思是，并不是所有的序偶组合都存在于偏序集中，只有存在
<span
class="math inline">(<em>a</em>,<em>b</em>) ∈ (<em>S</em>,≼)</span>
时才说 <span class="math inline"><em>a</em></span> 和 <span
class="math inline"><em>b</em></span> 可比，即有 <span
class="math inline"><em>a</em> ≼ <em>b</em></span>，否则就是不可比的。例如在偏序集
<span class="math inline">$(\textbf Z^+, |)$</span> 中（<span
class="math inline">|</span> 表示整除关系），<span
class="math inline">5</span> 和 <span class="math inline">7</span>
就不是可比的，因为 <span class="math inline">$(5,7)\notin(\textbf
Z^+,|)$</span>。</p>
<p>事实上，之所以说叫“偏”序，就是因为可能存在有些元素是不可比的。如果集合中的每个元素都可比，那么就称这个关系为<strong>全序</strong>，称这个集合为<strong>全序集</strong>（或线序集或链）。</p>
<p>对于偏序集 <span class="math inline">(<em>S</em>,≼)</span>，如果
<span class="math inline">≼</span> 是全序，并且 <span
class="math inline"><em>S</em></span>
的每个非空子集都有一个最小元素，那么就称它为<strong>良序集</strong>。例如，<span
class="math inline">$\textbf Z^+\times\textbf Z^+$</span> 的元素是形如
<span class="math inline">(<em>a</em>,<em>b</em>)</span>
的序偶，如果我们按顺序比较两个元素的大小，就有 <span
class="math inline">(1,5) &lt; (2,3)</span> 或 <span
class="math inline">(2,3) &lt; (2,6)</span>，由于 <span
class="math inline">$\textbf Z^+$</span> 是正整数集，所以最小元素就是
0，因此 <span class="math inline">$\textbf Z^+\times\textbf Z^+$</span>
的最小元素就是 <span class="math inline">(0,0)</span>，这说明 <span
class="math inline">$\textbf Z^+\times\textbf Z^+$</span> 是良序集。但
<span class="math inline">$\textbf Z\times\textbf Z$</span>
就不是良序集，因为其中包含负数，那就不存在这样的最小元素。</p>
<h4 id="哈塞图">6.7.2 哈塞图</h4>
<p>偏序仍然是一种关系，关系可以用图来表示，这里引出哈塞图，它忽略由于偏序的自反性和传递性而必须出现的边。如果关系是全序的（各个元素之间都存在关系，即都可比），你就会发现其哈塞图是一条链条，这就是称全序集为链的原因。</p>
<p>构造哈塞图的过程：</p>
<ol type="1">
<li>去掉所有结点上的环（这是由于自反性造成的）</li>
<li>去掉所有这样的边 <span
class="math inline">(<em>x</em>,<em>y</em>)</span>：存在元素 <span
class="math inline"><em>z</em> ∈ <em>S</em></span> 满足 <span
class="math inline"><em>x</em> ≼ <em>z</em></span> 和 <span
class="math inline"><em>z</em> ≼ <em>y</em></span>（这是由传递性造成的）</li>
<li>排列每条边，使大的元素在上，去掉所有箭头（因为所有箭头都指向顶线）</li>
</ol>
<p>通过哈塞图可以很直观地看出<strong>极大元</strong>/<strong>极小元</strong>（maximal/minimal）、<strong>最大元</strong>/<strong>最小元</strong>（greatest/least），只需要看哈塞图最顶端和最底端的元素是什么就行了。但是注意，极大元/极小元是指集合中没有其他元素大于/小于该元素，但是可以无法比较，这意味着极大元/极小元允许有多个；而最大元/最小元要求集合中所有元素都严格小于/大于它，不允许存在与它处于同一层但是无法比较的元素，也就是说如果一个哈塞图中，顶端元素不止一个，那这个偏序就不存在极大元；如果底端元素不止一个，那这个偏序就不存在极小元。</p>
<p>再介绍<strong>上/下界</strong>、<strong>上/下确界</strong>的概念：设
<span class="math inline">(<em>S</em>,≼)</span> 为偏序集，且 <span
class="math inline"><em>A</em></span> 是 <span
class="math inline"><em>S</em></span> 的一个子集，若 <span
class="math inline"><em>S</em></span> 中存在一个元素 <span
class="math inline"><em>a</em></span>，使得 <span
class="math inline"><em>A</em></span> 中任意一个元素 <span
class="math inline"><em>b</em></span> 都存在 <span
class="math inline"><em>b</em> ≼ <em>a</em></span>，则称 <span
class="math inline"><em>a</em></span> 为 <span
class="math inline"><em>A</em></span>
的上界；反之得到下界（上/下界中的元素不一定要和 <span
class="math inline"><em>A</em></span>
中元素都可比，只需比可比元素大/小就行了）。若 <span
class="math inline"><em>a</em></span> 是 <span
class="math inline"><em>A</em></span> 的上界集合中的<u>最小元</u>，则称
<span class="math inline"><em>a</em></span> 为上确界；若 <span
class="math inline"><em>a</em></span> 是 <span
class="math inline"><em>A</em></span> 的下界集合中的<u>最大元</u>，则称
<span class="math inline"><em>a</em></span> 为下确界。</p>
<h4 id="格">6.7.3 格</h4>
<p>如果一个偏序集的每一对元素都有上确界和下确界，就称这个偏序集为<strong>格</strong>。</p>
<p>下面来看一个例子（哈塞图本不应该带箭头，下图在这点上有误，请不要被误导）：</p>
<pre class="mermaid">graph TD
    a --> b
    b --> c
    b --> d
    c --> e
    d --> e
    e --> f</pre>
<p>假设我们选取 <span
class="math inline">{<em>c</em>, <em>d</em>}</span>，那么凡是在它们上面的（<span
class="math inline"><em>a</em></span> 和 <span
class="math inline"><em>b</em></span>）都是上界，凡是在它们下面的（<span
class="math inline"><em>e</em></span> 和 <span
class="math inline"><em>f</em></span>）都是下界。但上确界只有 <span
class="math inline"><em>b</em></span>，下确界只有 <span
class="math inline"><em>e</em></span>。</p>
<p>假设我们选取 <span
class="math inline">{<em>c</em>, <em>b</em>}</span>，注意，它们的上界并不只有
<span class="math inline"><em>a</em></span>，还有 <span
class="math inline"><em>b</em></span>，为什么？注意上下界的定义是 <span
class="math inline">∀<em>b</em> ∈ <em>A</em>(<em>b</em>≼<em>a</em>)</span>，这里是允许等于的，这里显然
<span class="math inline"><em>b</em> ≼ <em>b</em></span> 且 <span
class="math inline"><em>b</em> ≼ <em>c</em></span>，所以 <span
class="math inline"><em>b</em></span> 自然也属于上界，同理，下界有 <span
class="math inline">{<em>c</em>, <em>e</em>, <em>f</em>}</span>。因此，<span
class="math inline">{<em>c</em>, <em>b</em>}</span> 的上确界就是 <span
class="math inline"><em>b</em></span>，下确界就是 <span
class="math inline"><em>c</em></span>。</p>
<p>那为什么刚刚讨论 <span
class="math inline">{<em>c</em>, <em>d</em>}</span> 的上下界时没有 <span
class="math inline"><em>c</em></span> 和 <span
class="math inline"><em>d</em></span>？因为 <span
class="math inline"><em>c</em></span> 和 <span
class="math inline"><em>d</em></span> 压根就不可比。</p>
<blockquote>
<p>这里要注意一件事：找上/下界、上/下确界时我们是在全集中找，但是找最大/小值、极大/小值时，我们仅在子集中找。例如在上例中找
<span class="math inline">{<em>c</em>, <em>b</em>, <em>e</em>}</span>
的极大值，我们只能找到 <span
class="math inline"><em>b</em></span>，而不会有 <span
class="math inline"><em>a</em></span>。</p>
</blockquote>
<p>显然，上图中任意对元素都存在上下确界，因此属于格，下面来看一个不属于格的例子。</p>
<pre class="mermaid">graph TD
    a --> b
    a --> c
    b --> d
    c --> e
    d --> f
    e --> f
    b --> e
    c --> d</pre>
<p>假设选取 <span
class="math inline">{<em>b</em>, <em>e</em>}</span>，则上确界为 <span
class="math inline"><em>a</em></span>，这一点毫无疑问。下界为 <span
class="math inline">{<em>d</em>, <em>e</em>, <em>f</em>}</span>，哪个是下确界？下确界是下界集合中的最大值，根据最大值的定义，由于
<span class="math inline"><em>f</em></span> 小于 <span
class="math inline"><em>d</em></span> 和 <span
class="math inline"><em>e</em></span>，<span
class="math inline"><em>d</em></span> 和 <span
class="math inline"><em>e</em></span>
又不可比，所以不存在最大值，因此不存在下确界，故上图不是格。</p>
<h4 id="拓扑排序">6.7.4 拓扑排序</h4>
<p>这个简单。</p>
<h2 id="图论">07 图论</h2>
<h3 id="基本概念-1">7.1 基本概念</h3>
<ol type="1">
<li>简单图：不存在多重边（不同的边连接同一对顶点）和环（存在指向自身的边）的图</li>
<li>多重图：存在多重边但不存在环的图</li>
<li>伪图：存在多重边或环的图</li>
</ol>
<p>上面的概念都针对无向图，下面是有向图：</p>
<ol type="1">
<li>简单有向图：不允许出现环和多重边的有向图</li>
<li>有向多重图：允许出现环和多重边的有向图</li>
</ol>
<p>在某些情况下，我们可能需要一张图中既有无向的边，又有有向的边，我们称这样的边为
混合图。</p>
<h3 id="图的术语">7.2 图的术语</h3>
<h4 id="基本概念-2">7.2.1 基本概念</h4>
<p>设有图 <span
class="math inline"><em>G</em> = (<em>V</em>,<em>E</em>)</span>，我们将顶点
<span class="math inline"><em>v</em> ∈ <em>V</em></span> 的相邻顶点记作
<span class="math inline"><em>N</em>(<em>v</em>)</span>，若有顶点集合
<span class="math inline"><em>A</em> ∈ <em>V</em></span>，则将 <span
class="math inline"><em>A</em></span> 中所有顶点的相邻顶点构成的集合记作
<span class="math inline"><em>V</em>(<em>A</em>)</span>，则有 <span
class="math inline"><em>V</em>(<em>A</em>) = ⋃<sub><em>v</em> ∈ <em>A</em></sub><em>N</em>(<em>v</em>)</span>。</p>
<p>我们将顶点的度记作 <span
class="math inline">deg (<em>v</em>)</span>，特殊地，如果 <span
class="math inline"><em>v</em></span> 是带有环的无向图结点，那么环对
<span class="math inline"><em>v</em></span> 的度做出双倍贡献。</p>
<p>度为 0 的顶点称为孤立的，度为 1 的顶点称为悬挂的。</p>
<p><strong>握手定理</strong>：无向图中，所有顶点度数之和为边数的两倍。</p>
<p>定理：无向图有偶数个度为奇数的顶点。</p>
<p>有向图中，将顶点的入度记为 <span
class="math inline">deg<sup>−</sup>(<em>v</em>)</span>，将出度记为 <span
class="math inline">deg<sup>+</sup>(<em>v</em>)</span>。</p>
<p>在有向图中，所有顶点的入度之和 等于 出度之和 等于 边数。</p>
<h4 id="特殊简单图">7.2.2 特殊简单图</h4>
<p>完全图：<span class="math inline"><em>n</em></span>
个结点的完全图记作 <span
class="math inline"><em>K</em><sub><em>n</em></sub></span>，完全图的特点是每个结点之间都有一条直接相连的边。</p>
<p>圈图：<span class="math inline"><em>n</em></span> 个顶点的圈图记作
<span
class="math inline"><em>C</em><sub><em>n</em></sub></span>，圈图的特点是所有结点围成一个圈。</p>
<p>轮图：在 <span
class="math inline"><em>C</em><sub><em>n</em></sub></span>
中添加一个顶点，并将这个顶点与其他顶点相连，就得到一个轮图 <span
class="math inline"><em>W</em><sub><em>n</em></sub></span>，像一个车轮。</p>
<p><span class="math inline"><em>n</em></span> 立方图：记作 <span
class="math inline"><em>Q</em><sub><em>n</em></sub></span>，有 <span
class="math inline">2<sup><em>n</em></sup></span>
个顶点，每个顶点用二进制编号，当且仅当两个顶点编号的海明距离为 1
时两个顶点相连。</p>
<h4 id="二分图">7.2.3 二分图</h4>
<p>有些图可以将顶点分成两部分，就像小时候做的连线题一样。例如表示一个村庄里的婚姻状况，那么有一堆顶点代表男性，一堆顶点代表女性，有婚姻关系的就可以连在一起，由于同性无法建立婚姻关系（至少在中国的法律层面不行）所以同性顶点之间不会有连线，故可以把表示两种性别的顶点分别拉到左右两边。</p>
<p>若一个图能被二分，则有 <span
class="math inline"><em>V</em><sub>1</sub>, <em>V</em><sub>2</sub> ∈ <em>V</em></span>，称
<span
class="math inline">(<em>V</em><sub>1</sub>,<em>V</em><sub>2</sub>)</span>
为 <span class="math inline"><em>G</em></span>
的顶点集的一个二部划分。</p>
<p>如何判断一个图是否为二分图：给图中每个顶点赋予两种不同的颜色，当且仅当能找到一种着色方法，使得同颜色的顶点之间不存在连线，说明这个图是二分图。</p>
<p>完全二分图：<span class="math inline"><em>V</em><sub>1</sub></span>
和 <span class="math inline"><em>V</em><sub>2</sub></span>
中的结点之间都有连线，记作 <span
class="math inline"><em>K</em><sub><em>m</em>, <em>n</em></sub></span>，其中
<span class="math inline"><em>m</em></span> 和 <span
class="math inline"><em>n</em></span> 分别是 <span
class="math inline"><em>V</em><sub>1</sub></span> 和 <span
class="math inline"><em>V</em><sub>2</sub></span> 中的顶点个数。</p>
<h4 id="从旧图构造新图">7.2.4 从旧图构造新图</h4>
<p>从一个图中抽出一部分顶点和边构成一张新图，后者被称为前者的<strong>子图</strong>，如果两张图不相等，就称后者为前者的<strong>真子图</strong>。</p>
<p>导出子图：如果有 <span
class="math inline"><em>G</em> = (<em>V</em>,<em>E</em>)</span>，<span
class="math inline"><em>G</em><sup>′</sup> = (<em>W</em>,<em>F</em>)</span>，其中
<span
class="math inline"><em>W</em> ⊂ <em>V</em></span>，且被选出的结点间，该有的边全都有，就称
<span class="math inline"><em>G</em><sup>′</sup></span> 是 <span
class="math inline"><em>G</em></span>
的导出子图（但凡删除一条边都不再是导出子图）。</p>
<p>并图：将两张图结合到一起得到的图称为并图，假设 <span
class="math inline"><em>G</em><sub>1</sub> = (<em>V</em><sub>1</sub>,<em>E</em><sub>1</sub>)</span>，<span
class="math inline"><em>G</em><sub>2</sub> = (<em>V</em><sub>2</sub>,<em>E</em><sub>2</sub>)</span>，则它们的并图为
<span
class="math inline"><em>G</em> = <em>G</em><sub>1</sub> ∪ <em>G</em><sub>2</sub> = (<em>V</em><sub>1</sub>∪<em>V</em><sub>2</sub>,<em>E</em><sub>1</sub>∪<em>E</em><sub>2</sub>)</span>.</p>
<h3 id="图的表示和同构">7.3 图的表示和同构</h3>
<h4 id="邻接表">7.3.1 邻接表</h4>
<p>这还用讲？</p>
<h4 id="邻阶矩阵">7.3.2 邻阶矩阵</h4>
<p>当用邻接矩阵表示伪图时，元素值代表边的数量。</p>
<h4 id="关联矩阵">7.3.3 关联矩阵</h4>
<p>关联矩阵的行号代表顶点编号，列号代表边编号。</p>
<h4 id="同构">7.3.4 同构</h4>
<p>两个图同构是指当忽略图的顶点编号后，两个图相等。</p>
<p>如何证明同构：假设 <span
class="math inline"><em>G</em><sub>1</sub></span> 中的任意顶点为 <span
class="math inline"><em>a</em></span>，<span
class="math inline"><em>G</em><sub>2</sub></span> 中的任意顶点为 <span
class="math inline"><em>b</em></span>，找一个满射函数 <span
class="math inline"><em>f</em></span> 使得 <span
class="math inline"><em>f</em>(<em>a</em>) = <em>b</em></span>，若当
<span class="math inline"><em>G</em><sub>1</sub></span> 中 <span
class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub></span>
相邻，<span class="math inline"><em>G</em><sub>2</sub></span> 中 <span
class="math inline"><em>f</em>(<em>a</em><sub>1</sub>)</span> 和 <span
class="math inline"><em>f</em>(<em>a</em><sub>2</sub>)</span>
也相邻时，则说明 <span class="math inline"><em>G</em><sub>1</sub></span>
和 <span class="math inline"><em>G</em><sub>2</sub></span> 同构。</p>
<p>说明两个图同构是一件很难的事情，但是我们可以通过<strong>同构不变量</strong>来简单说明两个图不同构，例如顶点数量、顶点的度、边的数量等。另外，还可以这样判断不同构：<strong>两张图中度相同的结点与连接它们的边所构成的图一定也是同构的</strong>（经常使用两个度相同的顶点之间的路径来是否长度相同来判断图不同构）。</p>
<p>一种比较简单的方式来说明两个图同构：找一个满射函数 <span
class="math inline"><em>f</em></span>，使得两个图的邻接矩阵相等。</p>
<h3 id="连通性">7.4 连通性</h3>
<p>通路是边的序列。当一个图是简单图时，我们可以直接用顶点的有序序列来表示一条通路（否则不行，因为这样的话一对顶点无法唯一确定一条边）。当通路的首尾顶点相同且长度大于
0 时，就构成了回路。一条不含重复边的回路叫做简单回路。</p>
<h4 id="无向图的连通性">7.4.1 无向图的连通性</h4>
<p>当图中任意两个顶点间都存在一条通路时，一个无向图是连通的。</p>
<p>在连通无向图中，每一对顶点之间都存在一条简单通路。</p>
<p>一个不连通的图实际就是几个连通的子图构成的图。<strong>连通分支</strong>就是指极大连通子图，所谓极大连通子图，首先是连通子图，齐次它不是其他任何连通子图的真子图。</p>
<p>有时候，删除某个顶点以及与之相连的边，会导致一个图中产生更多的连通子图，这种点称为<strong>割点</strong>。删除某条边导致一个图中产生更多的连通子图，这种边称为<strong>割边</strong>或<strong>桥</strong>。</p>
<h4 id="有向图的连通性">7.4.2 有向图的连通性</h4>
<p>如果有向图中，对于任意一对顶点 <span
class="math inline"><em>a</em></span> 和 <span
class="math inline"><em>b</em></span>，都有从 <span
class="math inline"><em>a</em></span> 到 <span
class="math inline"><em>b</em></span> 和 <span
class="math inline"><em>b</em></span> 到 <span
class="math inline"><em>a</em></span> 的通路，那就称该图是强连通的。</p>
<p>如果把一个有向图改成无向图后（这个无向图称为该有向图的基本无向图），任意两个顶点都连通，那就说这个有向图是弱连通的。</p>
<p>强连通分支：是有向图的连通分支且是强连通的。</p>
<h4 id="通路与同构">7.4.3 通路与同构</h4>
<p>有多种方式来利用通路和回路判断一个图是否同构。比如，特定长度的回路就是一个有用的<strong>同构不变量</strong>。</p>
<h4 id="计算通路数">7.4.4 计算通路数</h4>
<p>假设一个图的邻接矩阵为 <span
class="math inline"><em>A</em></span>，那么 <span
class="math inline"><em>A</em><sup><em>n</em></sup></span>
（是正常的矩阵乘法不是布尔积！）中 <span
class="math inline">(<em>i</em>,<em>j</em>)</span>
上的元素就代表了该图中顶点 <span class="math inline"><em>i</em></span>
和顶点 <span class="math inline"><em>j</em></span> 之间长为 <span
class="math inline"><em>n</em></span> 的路径数量。</p>
<h3 id="欧拉通路和哈密顿通路">7.5 欧拉通路和哈密顿通路</h3>
<h4 id="欧拉通路和欧拉回路">7.5.1 欧拉通路和欧拉回路</h4>
<p>欧拉通路：指一张图中包含了该图全部边的简单通路。</p>
<p>欧拉回路：指一张图中包含了该图全部边的简单回路。</p>
<p>一个有 <span class="math inline">2</span>
个及以上的连通多重图有欧拉回路的充要条件：每个顶点的度都是偶数。</p>
<p>构造欧拉回路的算法（<span
class="math inline"><em>O</em>(|<em>E</em>|)</span>）：</p>
<ol type="1">
<li>从图中的任意一个顶点出发
，沿着边行走，形成一条回路，要求每条边只能走一次，但可以重复经过顶点，直到无法继续前进（即所有与当前顶点相连的边都已被走过）。</li>
<li>若此时回路包含了图中的所有边 ，则该回路就是欧拉回路。</li>
<li>如果回路中还没有包含所有边
，则在回路中找到一个顶点，该顶点存在还未被走过的边。从这个顶点出发，继续沿着未走过的边行走，形成一个新的回路，并将这个新回路插入到原回路中，替换掉原来的那个顶点。重复这个过程，直到所有的边都被包含在回路中。</li>
</ol>
<p>一个连通多重图只有欧拉通路没有欧拉回路的充要条件：恰有 2
个度为奇数的顶点。</p>
<h4 id="哈密顿通路和哈密顿回路">7.5.2 哈密顿通路和哈密顿回路</h4>
<p>哈密顿通路：指一张图中包含了该图全部顶点的简单通路。</p>
<p>哈密顿回路：指一张图中包含了该图全部顶点的简单回路。</p>
<p>目前不存在已知的简单的充要条件来判断一个图中是否含有哈密顿通路和哈密顿回路。但是有这么几个性质：</p>
<ol type="1">
<li>存在度为1的顶点的图不存在哈密顿通路</li>
<li>若一个顶点的度为2，且该图存在哈密顿通路，那么这个顶点的两条边肯定属于哈密顿通路</li>
<li>一个哈密顿回路不可能含有其他回路</li>
</ol>
<p>狄拉克定理：如果<span class="math inline"><em>G</em></span>是有<span
class="math inline"><em>n</em></span>个顶点的简单图，其中<span
class="math inline"><em>n</em> ≥ 3</span>，并且<span
class="math inline"><em>G</em></span>中每个顶点的度都至少是<span
class="math inline">⌈<em>n</em>/2⌉</span>，则<span
class="math inline"><em>G</em></span>有哈密顿回路。</p>
<p>欧尔定理：如果<span class="math inline"><em>G</em></span>是有<span
class="math inline"><em>n</em></span>个顶点的简单图，其中<span
class="math inline"><em>n</em> ≥ 3</span>，并且对于<span
class="math inline"><em>G</em></span>中每一对不相邻的顶点<span
class="math inline"><em>u</em></span>和<span
class="math inline"><em>v</em></span>来说，都有<span
class="math inline">deg (<em>u</em>) + deg (<em>v</em>) ≥ <em>n</em></span>，则<span
class="math inline"><em>G</em></span>有哈密顿回路。</p>
<blockquote>
<p>狄拉克定理可以看作是欧尔定理的推论。不论是狄拉克定理还是欧尔定理，都只是充分条件，并没有给出必要条件。也就是说这里存在一些图，既不满足狄拉克定理，也不满足欧尔定理，但它含有哈密顿回路。</p>
</blockquote>
<h3 id="平面图">7.6 平面图</h3>
<p>如果有办法可以使边无交叉地画出一幅图，那么就称这幅图为<strong>平面图</strong>，把这个画法称为前者的<strong>平面表示</strong>。</p>
<h4 id="欧拉公式">7.6.1 欧拉公式</h4>
<p>一个平面图可以把纸面分隔成好几个二维空间（其中有一个是无限平面），这样的二维空间称为一个<strong>面</strong>。</p>
<p>欧拉公式：设 <span class="math inline"><em>G</em></span> 是带 <span
class="math inline"><em>e</em></span> 条边和 <span
class="math inline"><em>v</em></span> 个顶点的连通平面简单图，设 <span
class="math inline"><em>r</em></span> 是 <span
class="math inline"><em>G</em></span> 的平面图表示中的面数，则 <span
class="math inline"><em>r</em> = <em>e</em> − <em>v</em> + 2</span>.</p>
<blockquote>
<p>注：如果不考虑外部面，则 <span
class="math inline"><em>r</em> = <em>e</em> − <em>v</em> + 1</span>。</p>
</blockquote>
<p>推论 1：若 <span class="math inline"><em>G</em></span> 是 <span
class="math inline"><em>e</em></span> 条边和 <span
class="math inline"><em>v</em></span> 个顶点的连通平面简单图，其中 <span
class="math inline"><em>v</em> ≥ 3</span>，则 <span
class="math inline"><em>e</em> ≤ 2<em>v</em> − 6</span>。</p>
<p>推论 2：若 <span class="math inline"><em>G</em></span>
是连通平面简单图，则 <span class="math inline"><em>G</em></span>
中有度数不超过 <span class="math inline">5</span> 的顶点。</p>
<p>推论 3：若 <span class="math inline"><em>G</em></span> 是 <span
class="math inline"><em>e</em></span> 条边和 <span
class="math inline"><em>v</em></span> 个顶点的连通平面简单图，且 <span
class="math inline"><em>v</em> ≥ 3</span> 且没有长度为 3 的回路，则
<span class="math inline"><em>e</em> ≤ 2<em>v</em> − 4</span>。</p>
<h4 id="库拉图斯基定理">7.6.2 库拉图斯基定理</h4>
<p>若<span
class="math inline"><em>G</em></span>是一个平面图，在它的某条边<span
class="math inline">{<em>a</em>, <em>c</em>}</span>上新建一个中间结点<span
class="math inline"><em>b</em></span>，使得原本的<span
class="math inline">{<em>a</em>, <em>c</em>}</span>被新增的两条边<span
class="math inline">{<em>a</em>, <em>b</em>}</span>和<span
class="math inline">{<em>b</em>, <em>c</em>}</span>替换掉，这样形成的新图仍然是平面图，这种操作称为<strong>初等细分</strong>。若两幅图可以通过对同一幅图进行初等细分来得到，则称这两张图是<strong>同胚</strong>的。</p>
<p>库拉图斯基定理：当且仅当图<span
class="math inline"><em>G</em></span>包含了同胚于<span
class="math inline"><em>K</em><sub>3, 3</sub></span>或<span
class="math inline"><em>K</em><sub>5</sub></span>的子图，<span
class="math inline"><em>G</em></span>是非平面图。</p>
<p>一般来说，直接应用库拉图斯基定理来判断非平面图是比较困难的，我们可以考虑对图进行逆向初等细分，即一步一步去掉中间结点，看是否能把图还原成<span
class="math inline"><em>K</em><sub>3, 3</sub></span>或<span
class="math inline"><em>K</em><sub>5</sub></span>。</p>
<h3 id="图着色">7.7 图着色</h3>
<p>对偶图：将一张地图的每块区域看作一个顶点，如果区域与区域之间有公共边界，那就认为它们对应的顶点是相邻的（如果仅仅是相交于一个点则不算），这样画出来的图叫这张地图的<strong>对偶图</strong>。</p>
<p>图着色是指为图中的每个顶点着色，要求没有一对相邻顶点的颜色是相同的。</p>
<p><strong>着色数</strong>是指使图<span
class="math inline"><em>G</em></span>中结点颜色各不相同所需要的最少颜色数，记作<span
class="math inline"><em>χ</em>(<em>G</em>)</span>。</p>
<p><strong>四色定理</strong>：平面图的着色数不超过4.（仅适用于平面图）</p>
<p>几个结论：</p>
<ol type="1">
<li><span
class="math inline"><em>χ</em>(<em>K</em><sub><em>n</em></sub>) = <em>n</em></span></li>
<li><span
class="math inline"><em>χ</em>(<em>K</em><sub><em>n</em>, <em>m</em></sub>) = 2</span></li>
<li>当<span class="math inline"><em>n</em></span>为偶数时，<span
class="math inline"><em>χ</em>(<em>C</em><sub><em>n</em></sub>) = 2</span>，当<span
class="math inline"><em>n</em></span>为奇数时，<span
class="math inline"><em>χ</em>(<em>C</em><sub><em>n</em></sub>) = 3</span></li>
</ol>
	  
	</div>

	<!-- recommended posts -->
	

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
		<li class="prev"><a href="/2025/04/07/Introduction-to-Program-Analysis/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
          <li class="next"><a href="/2023/12/18/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
        
	
</ul>
</div>

    </center>
	</div>

    <!-- share -->
    
        
    <div class="bdsharebuttonbox">
        <a href="#" class="bds_more" data-cmd="more"></a>
        <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
        <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
        <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
        <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
        <a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
        <a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a>
        <a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a>
        <a href="#" class="bds_copy" data-cmd="copy" title="分享到复制网址"></a>
    </div>
    <script>
        window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};
        with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>


        

    
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">Comments</h2>
  
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2025-03-18 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/discrete-math/">discrete math<span>1</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/lecture-notes/">lecture notes<span>7</span></a></li>

    </ul>
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E9%80%BB%E8%BE%91%E5%92%8C%E8%AF%81%E6%98%8E"><span class="toc-article-text">01 逻辑和证明</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91"><span class="toc-article-text">1.1 命题逻辑</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91"><span class="toc-article-text">1.2 谓词逻辑</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%B5%8C%E5%A5%97%E9%87%8F%E8%AF%8D"><span class="toc-article-text">1.4 嵌套量词</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-article-text">1.5 推理规则</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-article-text">1.5.1 命题逻辑的推理规则</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%87%8F%E5%8C%96%E5%91%BD%E9%A2%98%E7%9A%84%E6%8E%A8%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-article-text">1.5.2 量化命题的推理规则</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%97%B4%E6%8E%A5%E8%AF%81%E6%98%8E"><span class="toc-article-text">1.5.3 间接证明</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E9%9B%86%E5%90%88%E5%87%BD%E6%95%B0%E5%9F%BA%E6%95%B0%E7%9F%A9%E9%98%B5"><span class="toc-article-text">02 集合、函数、基数、矩阵</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%9B%86%E5%90%88"><span class="toc-article-text">2.1 集合</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-article-text">2.1.1 子集</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF"><span class="toc-article-text">2.1.2 笛卡尔积</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%9C%9F%E5%80%BC%E9%9B%86"><span class="toc-article-text">2.1.3 真值集</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-article-text">2.2 集合运算</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-article-text">2.2.1 运算</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%9B%86%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F"><span class="toc-article-text">2.2.2 集合恒等式</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-article-text">2.3 函数</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%BA%E6%95%B0"><span class="toc-article-text">2.4 基数</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-article-text">2.5 矩阵</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E8%AE%A1%E6%95%B0"><span class="toc-article-text">03 计数</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86"><span class="toc-article-text">3.1 鸽巢原理</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="toc-article-text">3.2 排列组合</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%9A%84%E6%8E%A8%E5%B9%BF"><span class="toc-article-text">3.3 排列组合的推广</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E5%BC%8F"><span class="toc-article-text">04 求解线性递推关系式</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%BA%BF%E6%80%A7%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E5%BC%8F"><span class="toc-article-text">4.1 线性常系数齐次递推关系式</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%8D%95%E6%A0%B9"><span class="toc-article-text">4.1.1 单根</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%87%8D%E6%A0%B9"><span class="toc-article-text">4.1.2 重根</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BB%BB%E6%84%8F%E9%98%B6"><span class="toc-article-text">4.1.3 任意阶</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%83%A8%E5%88%86%E9%87%8D%E6%A0%B9"><span class="toc-article-text">4.1.4 部分重根</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%BA%BF%E6%80%A7%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%9D%9E%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E5%BC%8F"><span class="toc-article-text">4.2 线性常系数非齐次递推关系式</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86"><span class="toc-article-text">05 容斥原理</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97"><span class="toc-article-text">5.1 错位排列</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E4%BC%8A%E6%8B%89%E8%84%B1%E6%A3%AE%E7%AD%9B"><span class="toc-article-text">5.2 埃拉托色尼筛(伊拉脱森筛)</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-article-text">06 关系</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-article-text">6.1 二元关系</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-article-text">6.1.1 性质</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E5%90%88%E6%88%90"><span class="toc-article-text">6.1.2 关系的合成</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%80%86%E5%85%B3%E7%B3%BB"><span class="toc-article-text">6.1.3 逆关系</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA"><span class="toc-article-text">6.2 关系表示</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%9F%A9%E9%98%B5-1"><span class="toc-article-text">6.2.1 矩阵</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%9B%BE"><span class="toc-article-text">6.2.2 图</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%85%B3%E9%97%AD%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-article-text">6.3 关闭的闭包</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-article-text">6.4 路径</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85"><span class="toc-article-text">6.5 传递闭包</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB"><span class="toc-article-text">6.6 等价关系</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%81%8F%E5%BA%8F"><span class="toc-article-text">6.7 偏序</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-article-text">6.7.1 基本概念</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%93%88%E5%A1%9E%E5%9B%BE"><span class="toc-article-text">6.7.2 哈塞图</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%A0%BC"><span class="toc-article-text">6.7.3 格</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-article-text">6.7.4 拓扑排序</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-article-text">07 图论</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-article-text">7.1 基本概念</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9B%BE%E7%9A%84%E6%9C%AF%E8%AF%AD"><span class="toc-article-text">7.2 图的术语</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-article-text">7.2.1 基本概念</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%89%B9%E6%AE%8A%E7%AE%80%E5%8D%95%E5%9B%BE"><span class="toc-article-text">7.2.2 特殊简单图</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-article-text">7.2.3 二分图</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BB%8E%E6%97%A7%E5%9B%BE%E6%9E%84%E9%80%A0%E6%96%B0%E5%9B%BE"><span class="toc-article-text">7.2.4 从旧图构造新图</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%90%8C%E6%9E%84"><span class="toc-article-text">7.3 图的表示和同构</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-article-text">7.3.1 邻接表</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%82%BB%E9%98%B6%E7%9F%A9%E9%98%B5"><span class="toc-article-text">7.3.2 邻阶矩阵</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5"><span class="toc-article-text">7.3.3 关联矩阵</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%90%8C%E6%9E%84"><span class="toc-article-text">7.3.4 同构</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-article-text">7.4 连通性</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-article-text">7.4.1 无向图的连通性</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-article-text">7.4.2 有向图的连通性</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E9%80%9A%E8%B7%AF%E4%B8%8E%E5%90%8C%E6%9E%84"><span class="toc-article-text">7.4.3 通路与同构</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E8%AE%A1%E7%AE%97%E9%80%9A%E8%B7%AF%E6%95%B0"><span class="toc-article-text">7.4.4 计算通路数</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF%E5%92%8C%E5%93%88%E5%AF%86%E9%A1%BF%E9%80%9A%E8%B7%AF"><span class="toc-article-text">7.5 欧拉通路和哈密顿通路</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF%E5%92%8C%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="toc-article-text">7.5.1 欧拉通路和欧拉回路</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%93%88%E5%AF%86%E9%A1%BF%E9%80%9A%E8%B7%AF%E5%92%8C%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF"><span class="toc-article-text">7.5.2 哈密顿通路和哈密顿回路</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%B9%B3%E9%9D%A2%E5%9B%BE"><span class="toc-article-text">7.6 平面图</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F"><span class="toc-article-text">7.6.1 欧拉公式</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%BA%93%E6%8B%89%E5%9B%BE%E6%96%AF%E5%9F%BA%E5%AE%9A%E7%90%86"><span class="toc-article-text">7.6.2 库拉图斯基定理</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%9B%BE%E7%9D%80%E8%89%B2"><span class="toc-article-text">7.7 图着色</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->




    </div>
  </div>
  <div class="container-narrow">
    <footer> <!--<p>
  &copy; 2025 me
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p>-->
 </footer>
  </div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


<!-- syntax highlighting -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
	<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</html>