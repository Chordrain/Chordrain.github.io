<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>计算机图形学 | Jiahao Peng</title>
    
    
        <meta name="keywords" content="graphics" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="这是我本科学习计算机图形学时所记的笔记，但是并不全面，仅有画线算法、扫描线算法、二维变换、样条表示四部分内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机图形学">
<meta property="og:url" content="https://example.com/2023/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/index.html">
<meta property="og:site_name" content="Jiahao Peng">
<meta property="og:description" content="这是我本科学习计算机图形学时所记的笔记，但是并不全面，仅有画线算法、扫描线算法、二维变换、样条表示四部分内容。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-01.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-02.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-03.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-04.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-05.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-06.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-07.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-08.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-09.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-10.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-11.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-12.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-13.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-14.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-15.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-16.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-17.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-18.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-20.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-19.png">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-22.gif">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-23.gif">
<meta property="og:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-21.gif">
<meta property="article:published_time" content="2023-12-10T03:38:36.000Z">
<meta property="article:modified_time" content="2025-04-09T11:50:27.892Z">
<meta property="article:author" content="me">
<meta property="article:tag" content="graphics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://example.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6-01.png">
    

    
        <link rel="alternate" href="/atom.xml" title="Jiahao Peng" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.ico" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Jiahao Peng</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Debugging
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2025/04/05/A-WSL-Error-Encountered-When-installing-Docker/">A WSL Error Encountered When Installing Docker</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            【Lecture】Software Analysis Testing and Verification
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2025/04/04/Introduction-to-Program-Analysis/">Introduction to Program Analysis</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            深度学习
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2023/09/09/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6-Self-attention/">自注意力机制 Self-attention</a></li>  <li class="file"><a href="/2023/10/24/Transformer/">Transformer</a></li>  <li class="file"><a href="/2024/04/03/%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/">图注意力机制的原理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            计算机专业基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2022/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-%E5%90%B4%E6%81%A9%E8%BE%BE/">机器学习入门 吴恩达</a></li>  <li class="file active"><a href="/2023/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">计算机图形学</a></li>  <li class="file"><a href="/2023/12/11/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF/">人工智能技术杂谈</a></li>  <li class="file"><a href="/2025/03/18/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">离散数学</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/2021/04/05/Welcome/">✨Welcome!✨</a></li>  </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><span>recent</span></h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Debugging/">Debugging</a></p>
                            <p class="item-title"><a href="/2025/04/05/A-WSL-Error-Encountered-When-installing-Docker/" class="title">A WSL Error Encountered When Installing Docker</a></p>
                            <p class="item-date"><time datetime="2025-04-05T14:30:36.000Z" itemprop="datePublished">2025-04-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/%E3%80%90Lecture%E3%80%91Software-Analysis-Testing-and-Verification/">【Lecture】Software Analysis Testing and Verification</a></p>
                            <p class="item-title"><a href="/2025/04/04/Introduction-to-Program-Analysis/" class="title">Introduction to Program Analysis</a></p>
                            <p class="item-date"><time datetime="2025-04-04T13:58:30.000Z" itemprop="datePublished">2025-04-04</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/">计算机专业基础</a></p>
                            <p class="item-title"><a href="/2025/03/18/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" class="title">离散数学</a></p>
                            <p class="item-date"><time datetime="2025-03-18T06:16:34.000Z" itemprop="datePublished">2025-03-18</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></p>
                            <p class="item-title"><a href="/2024/04/03/%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/" class="title">图注意力机制的原理</a></p>
                            <p class="item-date"><time datetime="2024-04-03T03:23:32.000Z" itemprop="datePublished">2024-04-03</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/">计算机专业基础</a></p>
                            <p class="item-title"><a href="/2023/12/11/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF/" class="title">人工智能技术杂谈</a></p>
                            <p class="item-date"><time datetime="2023-12-11T06:15:50.000Z" itemprop="datePublished">2023-12-11</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><span>tag cloud</span></h3>
        <div class="widget tagcloud">
            <a href="/tags/a-star/" style="font-size: 10px;">a-star</a> <a href="/tags/ai/" style="font-size: 10px;">ai</a> <a href="/tags/attention/" style="font-size: 20px;">attention</a> <a href="/tags/deduction/" style="font-size: 10px;">deduction</a> <a href="/tags/discrete-math/" style="font-size: 10px;">discrete math</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/error/" style="font-size: 10px;">error</a> <a href="/tags/gnn/" style="font-size: 10px;">gnn</a> <a href="/tags/graphics/" style="font-size: 10px;">graphics</a> <a href="/tags/heuristic-search/" style="font-size: 10px;">heuristic search</a> <a href="/tags/hmm/" style="font-size: 10px;">hmm</a> <a href="/tags/machine-learning/" style="font-size: 20px;">machine learning</a> <a href="/tags/program-analysis/" style="font-size: 10px;">program analysis</a> <a href="/tags/svm/" style="font-size: 10px;">svm</a> <a href="/tags/transformer/" style="font-size: 10px;">transformer</a> <a href="/tags/vscode/" style="font-size: 10px;">vscode</a>
        </div>
    </div>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-计算机图形学" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/">计算机专业基础</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/graphics/" rel="tag">graphics</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2023/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">
            <time datetime="2023-12-10T03:38:36.000Z" itemprop="datePublished">2023-12-10</time>
        </a>
    </div>


                        
                        
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            计算机图形学
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">Catalogue</strong>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%BB%E7%BA%BF%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">01 画线算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dda-%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 DDA 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bresenham-%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Bresenham 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">02 填充算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9B%AE%E6%A0%87"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 算法目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 算法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 算法的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-1"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%8F%98%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">03 二维变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 平移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 齐次坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8F%98%E6%8D%A2"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 逆变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8F%98%E6%8D%A2"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 复合变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E5%88%87"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 错切</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A-2"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 作业</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E6%9D%A1%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.</span> <span class="toc-text">04 样条表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 曲线曲面的表示方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%9A%84%E7%BB%98%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 曲线曲面的绘制方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hermite-%E6%9B%B2%E7%BA%BF"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Hermite 曲线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bezier-%E6%9B%B2%E7%BA%BF"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Bezier 曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1-bezier-%E6%9B%B2%E7%BA%BF"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 一次 Bezier 曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1-bezier-%E6%9B%B2%E7%BA%BF"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3 二次 Bezier 曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1-bezier-%E6%9B%B2%E7%BA%BF"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4 三次 Bezier 曲线</span></a></li></ol></li></ol></li></ol>
                </div>
            
        
        
            <h2 id="画线算法">01 画线算法</h2>
<p>本节主要掌握 DDA 算法和 Bresenham 算法。DDA
算法主要是由笛卡尔斜率截距方程导出的，而 Bresenham 算法则算是对 DDA
算法的改进。</p>
<p>笛卡尔斜率截距方程为：<span
class="math inline"><em>y</em> = <em>m</em><em>x</em> + <em>b</em></span>，笛卡尔斜率截距方程告诉我们，如果已知一条直线上的两个端点
<span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>)</span>
和 <span
class="math inline">(<em>x</em><sub><em>e</em><em>n</em><em>d</em></sub>,<em>y</em><sub><em>e</em><em>n</em><em>d</em></sub>)</span>，我们就能确定该直线的斜率和截距：</p>
<p><span class="math display">$$
\begin{aligned}
&amp;m=\frac{x_{end}-x_{0}}{y_{end}-y_{0}}\\
&amp;b=y_{0}-m·x_{0}
\end{aligned}
$$</span></p>
<p>如果令直线在 x 轴上让线段延长一段距离 <span
class="math inline"><em>δ</em><em>x</em></span>，那么对应的，y
轴上就应该延长 <span
class="math inline"><em>δ</em><em>y</em> = <em>m</em> · <em>δ</em><em>x</em></span>；反过来，如果令直线在
y 轴上延长一段距离 <span
class="math inline"><em>δ</em><em>y</em></span>，那么在 x 轴上就要延长
<span class="math inline">$\delta x=\frac{\delta
y}{m}$</span>。这两个公式被称为<strong>增量公式</strong>。</p>
<span id="more"></span>
<h3 id="dda-算法">1.1 DDA 算法</h3>
<p>计算机是使用一系列离散的像素点来近似非水平或垂直的直线和其他图案的，要画的直线在大部分向前看不可能刚刚好穿过一系列在水平或垂直方向上连续的像素点，所以画线算法的重点就在于确定所画线段要经过的像素点的横纵坐标。DDA
算法的思想是：通过在 x 轴或 y 轴上设置一个微小的步距 <span
class="math inline"><em>s</em><em>t</em><em>e</em><em>p</em></span>，然后通过上述的增量公式，来得到另一个轴上对应的坐标。</p>
<p>倘若我们选择在 x 轴上设置步距，也就是 x 轴上的更新公式是 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + <em>s</em><em>t</em><em>e</em><em>p</em><sub><em>x</em></sub></span>，那么对应
y 轴上的更新公式应该为 <span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + <em>m</em> · <em>s</em><em>t</em><em>e</em><em>p</em><sub><em>x</em></sub></span>；倘若我们选择在
y 轴上设置步距，也就是 y 轴上的更新公式是 <span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + <em>s</em><em>t</em><em>e</em><em>p</em><sub><em>y</em></sub></span>，那么对应
x 轴上的更新公式应该为 <span
class="math inline">$x_{k+1}=x_{k}+\frac{step_{y}}{m}$</span>.</p>
<p>那么具体应该选择 x 轴还是 y 轴？按照 DDA 算法的规定，当 <span
class="math inline">|<em>m</em>| &lt; 1</span> 时，应该选取 x 轴；而当
<span class="math inline">|<em>m</em>| &gt; 1</span> 时，应该选取 y
轴。这是因为，当 <span class="math inline">|<em>m</em>| &lt; 1</span>
时，y 上移动 <span
class="math inline"><em>s</em><em>e</em><em>t</em><em>p</em><sub><em>y</em></sub></span>，x
上要移动的距离 <span
class="math inline">$step_{x}=\frac{step_{y}}{m}&gt;step_{y}$</span>，如果此时选择
y 轴作为移动的主轴，会导致 x 轴上移动的步距过大，精度下降，所以应该 选择
x 轴作为移动的主轴，反之亦然。</p>
<p>以上就是 DDA 算法的思想，那么所谓的步距 <span
class="math inline"><em>s</em><em>t</em><em>e</em><em>p</em></span>
具体应该取何值？显然，<span
class="math inline"><em>s</em><em>t</em><em>e</em><em>p</em></span>
应该取主轴上的像素点的单位间隔，课本上直接取了 <span
class="math inline">1</span>.
如果终止点的位置落在起始点的右边，也就是移动的位置应该相反，则此时的步距应该为负数，也就是
<span class="math inline"> − 1</span>. 另外，由于 <span
class="math inline"><em>m</em></span> 可能为浮点数，使得计算出的 <span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub></span> 和 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub></span>
也为浮点数，应该对最终结果予以<strong>四舍五入</strong>。</p>
<ul>
<li>总结：DDA 算法的执行步骤是
<ol type="1">
<li>根据 <span class="math inline"><em>m</em></span>
的大小选择移动轴</li>
<li>移动轴每次移动一步 (<span
class="math inline"> + 1</span>)，并将移动轴的坐标带入直线方程求另一条轴的坐标</li>
<li>对求得的坐标进行四舍五入，得到完整坐标</li>
<li>重复步骤 2 和 3，直到到达终止点为止</li>
</ol></li>
<li>DDA 算法的优缺点：
<ul>
<li>优点：消除了算法中的乘法，简单易懂</li>
<li>缺点：有浮点数的计算，并伴随浮点数相加累积误差，对长线段而言容易引起像素点位置与理想位置的较大偏移；四舍五入操作消耗时间</li>
</ul></li>
</ul>
<h3 id="bresenham-算法">1.2 Bresenham 算法</h3>
<p>Bresenham
算法的思想很简单，它直接选取与目标直线<strong>垂直距离</strong>最近的像素点，例如下图中的两点，很明显应该选择
<span
class="math inline">(<em>x</em><sub><em>k</em></sub>+1,<em>y</em><sub><em>k</em></sub>+1)</span>：</p>
<p><img src="/img/计算机图形学-01.png" /></p>
<p>但 Bresenham
的数学原理是有点复杂的，因为它使用递推的手段去求解决策参数，避免了大量的浮点数运算和四舍五入的操作。接下来是数学公式的推导，<del>可以不看</del>。</p>
<p>假设我们要画一条线段，起始点为 <span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>)</span>，终止点为
<span
class="math inline">(<em>x</em><sub>1</sub>,<em>y</em><sub>1</sub>)</span>，令
<span
class="math inline"><em>Δ</em><em>x</em> = <em>x</em><sub>1</sub> − <em>x</em><sub>0</sub></span>，<span
class="math inline"><em>Δ</em><em>y</em> = <em>y</em><sub>1</sub> − <em>y</em><sub>0</sub></span>，<span
class="math inline"><em>m</em> ∈ (0,1)</span> 为该线段的斜率且有 <span
class="math inline">$m=\frac{\Delta y}{\Delta x}$</span>，<span
class="math inline"><em>b</em></span> 为截距，假设现在已经求得了第 <span
class="math inline"><em>k</em></span> 个点为 <span
class="math inline">(<em>x</em><sub><em>k</em></sub>,<em>y</em><sub><em>k</em></sub>)</span>，现在讨论在
<span class="math inline"><em>x</em><sub><em>k</em> + 1</sub></span>
处描点的情况。</p>
<blockquote>
<p>注意：这里非常容易弄混 <span
class="math inline"><em>x</em><sub><em>k</em></sub></span>、<span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub></span>、<span
class="math inline"><em>x</em><sub><em>k</em></sub> + 1</span> 和 <span
class="math inline"><em>y</em><sub><em>k</em></sub></span>、<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub></span>、<span
class="math inline"><em>y</em><sub><em>k</em></sub> + 1</span>
之间的关系，<span
class="math inline">(<em>x</em><sub><em>k</em></sub>,<em>y</em><sub><em>k</em></sub>)</span>
是上一个已知的点，现在要求的是在 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub></span>
处的点，而 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> ∈ {<em>y</em><sub><em>k</em></sub>, <em>y</em><sub><em>k</em></sub> + 1}</span>。</p>
</blockquote>
<p>将 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub></span>
带入直线方程可得该点处 y 轴的精确值为 <span
class="math inline"><em>y</em> = <em>m</em>(<em>x</em><sub><em>k</em></sub>+1) + <em>b</em></span>，设
<span
class="math inline"><em>d</em><sub><em>u</em><em>p</em><em>p</em><em>e</em><em>r</em></sub></span>
和 <span
class="math inline"><em>d</em><sub><em>l</em><em>o</em><em>w</em><em>e</em><em>r</em></sub></span>
分别为 <span class="math inline"><em>y</em><sub><em>k</em></sub></span>
和 <span class="math inline"><em>y</em><sub><em>k</em></sub> + 1</span>
与 <span class="math inline"><em>y</em></span>
的差值，也就是可选的两个点与精确位置的垂直距离，则有：</p>
<p><span class="math display">$$
\begin{aligned}
&amp;d_{upper}=y_{k}+1-y\\
&amp;d_{lower}=y-y_{k}
\end{aligned}
$$</span></p>
<p>将 <span
class="math inline"><em>y</em> = <em>m</em>(<em>x</em><sub><em>k</em></sub>+1) + <em>b</em></span>
带入就有：</p>
<p><span class="math display">$$
\begin{aligned}
&amp;d_{upper}=y_{k}+1-m(x_{k}+1)-b\\
&amp;d_{lower}=m(x_{k}+1)+b-y_{k}
\end{aligned}
$$</span></p>
<p>根据 Bresenham
算法的思想，应该将上面两个值相减求差，根据差的正负号来判断哪个点离线段更近，则有：</p>
<p><span class="math display">$$
\begin{aligned}
\Delta
d=d_{lower}-d_{upper}&amp;=m(x_{k}+1)+b-y_{k}-y_{k}-1+m(x_{k}+1)+b\\
&amp;=2m(x_{k}+1)-2y_{k}+2b-1\\
\end{aligned}
$$</span></p>
<p>接下来定义一个决策参数 <span
class="math inline"><em>p</em><sub><em>k</em></sub></span>，其值为：</p>
<p><span class="math display">$$
\begin{aligned}
p_{k}&amp;=\Delta x·\Delta d\\
&amp;=\Delta x(2m(x_{k}+1)-2y_{k}+2b-1)\\
&amp;\Downarrow m=\frac{\Delta y}{\Delta x}\\
&amp;=2\Delta y(x_{k}+1)-2\Delta x·y_{k}+\Delta x(2b-1)\\
&amp;=2\Delta y·x_{k}-2\Delta x·y_{k}+2\Delta y+\Delta x(2b-1)\\
&amp;=2\Delta y·x_{k}-2\Delta x·y_{k}+c
\end{aligned}
$$</span></p>
<p>由于 <span
class="math inline"><em>Δ</em><em>x</em> &gt; 0</span>，所以乘上它并不会改变
<span class="math inline"><em>Δ</em><em>d</em></span> 的正负性，最后
<span
class="math inline">2<em>Δ</em><em>y</em> + <em>Δ</em><em>x</em>(2<em>b</em>−1)</span>
这一项为常数项，在循环计算 <span
class="math inline"><em>p</em><sub><em>k</em></sub></span>
时可以消除，所以可以不管；乘上 <span
class="math inline"><em>Δ</em><em>x</em></span>
是为了后续计算方便，简化最终的递推式形式。</p>
<p>根据 <span class="math inline"><em>p</em><sub><em>k</em></sub></span>
的正负性可以得到： 1. <span
class="math inline"><em>p</em><sub><em>k</em></sub> &lt; 0</span> 时，即
<span
class="math inline"><em>d</em><sub><em>l</em><em>o</em><em>w</em><em>e</em><em>r</em></sub> &lt; <em>d</em><sub><em>u</em><em>p</em><em>p</em><em>e</em><em>r</em></sub></span>
时，应选择 <span
class="math inline"><em>y</em><sub><em>k</em></sub></span> 作为 <span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub></span> 2. <span
class="math inline"><em>p</em><sub><em>k</em></sub> &gt; 0</span> 时，即
<span
class="math inline"><em>d</em><sub><em>l</em><em>o</em><em>w</em><em>e</em><em>r</em></sub> &gt; <em>d</em><sub><em>u</em><em>p</em><em>p</em><em>e</em><em>r</em></sub></span>
时，应选择 <span
class="math inline"><em>y</em><sub><em>k</em></sub> + 1</span> 作为
<span class="math inline"><em>y</em><sub><em>k</em> + 1</sub></span></p>
<p>从 <span class="math inline"><em>p</em><sub><em>k</em></sub></span>
的式子很容易得出 <span
class="math inline"><em>p</em><sub><em>k</em> + 1</sub></span>
的情况：</p>
<p><span
class="math display"><em>p</em><sub><em>k</em> + 1</sub> = 2<em>Δ</em><em>y</em> · <em>x</em><sub><em>k</em> + 1</sub> − 2<em>Δ</em><em>x</em> · <em>y</em><sub><em>k</em> + 1</sub> + <em>c</em></span></p>
<p>将上面两式相减：</p>
<p><span class="math display">$$
\begin{aligned}
p_{k+1}-p_{k}&amp;=2\Delta y(x_{k+1}-x_{k})-2\Delta x(y_{k+1}-y_{k})\\
&amp;\Downarrow x_{k+1}=x_{k}+1\\
p_{k+1}&amp;=p_{k}+2\Delta y-2\Delta x(y_{k+1}-y_{k})
\end{aligned}
$$</span></p>
<ol type="1">
<li>如果 <span
class="math inline"><em>p</em><sub><em>k</em></sub> &lt; 0</span>，则
<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub></span>，则
<span
class="math inline"><em>p</em><sub><em>k</em> + 1</sub> = <em>p</em><sub><em>k</em></sub> + 2<em>Δ</em><em>y</em></span></li>
<li>如果 <span
class="math inline"><em>p</em><sub><em>k</em></sub> &gt; 0</span>，则
<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + 1</span>，则
<span
class="math inline"><em>p</em><sub><em>k</em> + 1</sub> = <em>p</em><sub><em>k</em></sub> + 2<em>Δ</em><em>y</em> − 2<em>Δ</em><em>x</em></span></li>
</ol>
<p>至此，我们就得到了 <span
class="math inline"><em>p</em><sub><em>k</em></sub></span>
的递推式，根据 <span
class="math inline"><em>p</em><sub><em>k</em></sub></span>
值的正负，我们就能知道是选择 <span
class="math inline"><em>y</em><sub><em>k</em></sub></span> 还是 <span
class="math inline"><em>y</em><sub><em>k</em></sub> + 1</span>.
现在，我们只需要知道 <span
class="math inline"><em>p</em><sub>0</sub></span>
就可以通过递推的方式直接计算之后的决策参数，<span
class="math inline"><em>p</em><sub>0</sub></span> 是在线段的起始点 <span
class="math inline">(<em>x</em><sub>0</sub>,<em>y</em><sub>0</sub>)</span>
处的情况，将该点和直线方程带入 <span
class="math inline"><em>p</em><sub><em>k</em></sub></span>
的定义式则有：</p>
<p><span class="math display">$$
\begin{aligned}
p_{0}&amp;=2\Delta y·x_{0}-2\Delta x·y_{0}+2\Delta y+\Delta x(2b-1)\\
&amp;\Downarrow y_{0}=mx_{0}+b,m=\frac{\Delta y}{\Delta x}\\
&amp;=2\Delta y·x_{0}-2\Delta x·(\frac{\Delta y}{\Delta
x}x_{0}+b)+2\Delta y+\Delta x(2b-1)\\
&amp;=2\Delta y-\Delta x
\end{aligned}
$$</span></p>
<p>至此，Bresenham 算法的数学推导就结束了。最后演示一下 <span
class="math inline"><em>p</em><sub>0</sub> → <em>p</em><sub>3</sub></span>
的递推过程： 1. <span
class="math inline"><em>p</em><sub>0</sub> = 2<em>Δ</em><em>y</em> − <em>Δ</em><em>x</em></span>，若
<span class="math inline"><em>p</em><sub>0</sub> &gt; 0</span>，则 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + 1</span>；若
<span class="math inline"><em>p</em><sub>0</sub> ≤ 0</span>，则 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub></span>；
2. <span
class="math inline"><em>p</em><sub>1</sub> = <em>p</em><sub>0</sub> + 2<em>Δ</em><em>y</em> − 2<em>Δ</em><em>x</em>(<em>y</em><sub>1</sub>−<em>y</em><sub>0</sub>)</span>，若
<span class="math inline"><em>p</em><sub>1</sub> &gt; 0</span>，则 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + 1</span>；若
<span class="math inline"><em>p</em><sub>1</sub> ≤ 0</span>，则 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub></span>；
3. <span
class="math inline"><em>p</em><sub>2</sub> = <em>p</em><sub>1</sub> + 2<em>Δ</em><em>y</em> − 2<em>Δ</em><em>x</em>(<em>y</em><sub>2</sub>−<em>y</em><sub>1</sub>)</span>，若
<span class="math inline"><em>p</em><sub>2</sub> &gt; 0</span>，则 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + 1</span>；若
<span class="math inline"><em>p</em><sub>2</sub> ≤ 0</span>，则 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub></span>；
4. <span
class="math inline"><em>p</em><sub>3</sub> = <em>p</em><sub>2</sub> + 2<em>Δ</em><em>y</em> − 2<em>Δ</em><em>x</em>(<em>y</em><sub>3</sub>−<em>y</em><sub>2</sub>)</span>，若
<span class="math inline"><em>p</em><sub>3</sub> &gt; 0</span>，则 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + 1</span>；若
<span class="math inline"><em>p</em><sub>3</sub> ≤ 0</span>，则 <span
class="math inline"><em>x</em><sub><em>k</em> + 1</sub> = <em>x</em><sub><em>k</em></sub> + 1</span>，<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub></span>；
5. …</p>
<hr />
<p>》参考：<a
target="_blank" rel="noopener" href="https://www.jianshu.com/p/c02ca154943b">【简书】Bresenham
画线算法推导</a>、<a
target="_blank" rel="noopener" href="https://blog.csdn.net/u010429424/article/details/77834046">【CSDN】DDA算法和Bresenham算法</a></p>
<hr />
<h3 id="作业">1.3 作业</h3>
<blockquote>
<p>绘制一条直线，端点分别为 <span class="math inline">(1,1)</span> 和
<span class="math inline">(7,5)</span>，使用 DDA 和 Bresenham
算法绘制。</p>
</blockquote>
<p>先计算斜率和截距：<span
class="math inline">$m=\frac{5-1}{7-1}=\frac{2}{3}$</span>，<span
class="math inline">$b=1-\frac{2}{3}·1=\frac{1}{3}$</span>，得到直线方程：<span
class="math inline">$y=\frac{2}{3}x+\frac{1}{3}$</span>。</p>
<ol type="1">
<li>DDA 算法</li>
</ol>
<p>由于 <span class="math inline">|<em>m</em>| &lt; 1</span>，以单位间隔
<span class="math inline"><em>δ</em><em>x</em> = 1</span> 在 x
轴上取样，算法执行过程如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline"><em>x</em></span></th>
<th style="text-align: center;"><span
class="math inline">$\frac{2}{3}x+\frac{1}{3}$</span></th>
<th style="text-align: center;"><span
class="math inline">(<em>x</em>,<em>y</em>)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span
class="math inline">(1,1)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">2</span></td>
<td style="text-align: center;"><span
class="math inline">$\frac{5}{3}$</span></td>
<td style="text-align: center;"><span
class="math inline">(2,2)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">3</span></td>
<td style="text-align: center;"><span
class="math inline">$\frac{7}{3}$</span></td>
<td style="text-align: center;"><span
class="math inline">(3,2)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">4</span></td>
<td style="text-align: center;"><span class="math inline">3</span></td>
<td style="text-align: center;"><span
class="math inline">(4,3)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">5</span></td>
<td style="text-align: center;"><span
class="math inline">$\frac{11}{3}$</span></td>
<td style="text-align: center;"><span
class="math inline">(5,4)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">6</span></td>
<td style="text-align: center;"><span
class="math inline">$\frac{13}{3}$</span></td>
<td style="text-align: center;"><span
class="math inline">(6,4)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">7</span></td>
<td style="text-align: center;"><span class="math inline">5</span></td>
<td style="text-align: center;"><span
class="math inline">(7,5)</span></td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>Bresenham 算法</li>
</ol>
<p>首先计算 <span
class="math inline"><em>Δ</em><em>x</em> = 7 − 1 = 6</span>，<span
class="math inline"><em>Δ</em><em>y</em> = 5 − 1 = 4</span>，算法执行过程如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline"><em>k</em></span></th>
<th style="text-align: center;"><span
class="math inline"><em>p</em><sub><em>k</em></sub></span></th>
<th style="text-align: center;"><span
class="math inline">(<em>x</em><sub><em>k</em> + 1</sub>,<em>y</em><sub><em>k</em> + 1</sub>)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">2</span></td>
<td style="text-align: center;"><span
class="math inline">(2,2)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span
class="math inline"> − 2</span></td>
<td style="text-align: center;"><span
class="math inline">(3,2)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">2</span></td>
<td style="text-align: center;"><span class="math inline">6</span></td>
<td style="text-align: center;"><span
class="math inline">(4,3)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">3</span></td>
<td style="text-align: center;"><span class="math inline">2</span></td>
<td style="text-align: center;"><span
class="math inline">(5,4)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">4</span></td>
<td style="text-align: center;"><span
class="math inline"> − 2</span></td>
<td style="text-align: center;"><span
class="math inline">(6,4)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">5</span></td>
<td style="text-align: center;"><span class="math inline">6</span></td>
<td style="text-align: center;"><span
class="math inline">(7,5)</span></td>
</tr>
</tbody>
</table>
<h2 id="填充算法">02 填充算法</h2>
<p>填充算法中，我们主要学习<strong>扫描线算法</strong>。</p>
<p>如何在计算机程序中存储几何图形
(多边形)？最容易的方法就是按顺序存储多边形的顶点，这个多边形就唯一确定了。那显示器是如何显示几何图形的呢？显示设备通常提供一个帧缓冲存储器
(俗称显存)，可以把它当做二维数组，该数组存储的值与屏幕上显示的每一像素的颜色一一对应。那么问题来了，如何把程序中的几何图形转换成显存中的几何图形？这就是扫描线算法要解决的问题。</p>
<h3 id="算法目标">2.1 算法目标</h3>
<p>扫描线多边形区域填充算法是按扫描线顺序
(<strong>由下到上</strong>)，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充工作。扫描线在对多边形进行扫描时，会与多边形产生多个交点，如下图所示：</p>
<p><img src="/img/计算机图形学-02.png" /></p>
<p>直接观察可以看出，在上图所示的扫描线中，x 轴坐标在 <span
class="math inline">[10,14]</span> 和 <span
class="math inline">[18,24]</span>
上的像素点位于多边形内部，在填充多边形时，只需要将这些点渲染成对应的颜色即可。但我们也看到，<span
class="math inline">(14,18)</span>
上的点并不在多边形内，所以它们不是要填充的部分，扫描线算法的核心就在于区分出哪些像素点位于多边形内，哪些位于多边形外。然而，这件事听起来简单，做起来却不容易。</p>
<p>上图展示的情形是最简单的一种，通过总结规律，我们可以发现，在扫描线不经过多边形的端点的情况下，其与多边形的交点数量永远是偶数，且在多边形区域内的线段与在多边形区域外的线段交替出现，利用这一性质，我们可以很容易地完成填充。但是，当扫描线刚刚好经过多边形的端点的时候，情况就变复杂了，如下图：</p>
<p><img src="/img/计算机图形学-03.png" /></p>
<p>上图画了两根扫描线 <span class="math inline"><em>y</em></span> 和
<span
class="math inline"><em>y</em><sup>′</sup></span>，它们的共同点是都经过了多边形的端点，不同点是扫描线
<span class="math inline"><em>y</em><sup>′</sup></span>
已经不满足上面所说的“在多边形区域内的线段与在多边形区域外的线段交替出现”这一性质了，而
<span class="math inline"><em>y</em></span>
则仍然遵守，那么，我们如何区分这两种情况，以及如何设计一个完备的算法处理？这是扫描线算法要解决的第一个问题。</p>
<p>此外，算法还需要求解扫描线与多边形的交点，一个直观的解法是：根据多边形的顶点求出各条边的方程，然后将扫描线的纵坐标代入方程求出横坐标。但是显然，这样做会涉及大量的乘法和除法运算，并且需要遍历每条扫描线和每条边，性能开销极大，设计一个合理的算法求解每条扫描线与多边形的交点，是扫描线算法要解决的第二个问题。</p>
<h3 id="算法原理">2.2 算法原理</h3>
<p>对于第一个问题，仔细观察上图可以发现两根扫描线在拓扑结构上的区别：<span
class="math inline"><em>y</em><sup>′</sup></span>
上的端点所连接的两条边皆在 <span
class="math inline"><em>y</em><sup>′</sup></span> 的上面，而 <span
class="math inline"><em>y</em></span> 上的端点所连接的两条边分别位列
<span class="math inline"><em>y</em></span>
的两边。根据这一区别，我们可以设计这样一个算法区分这两种情况，并把它们转换为最好处理的情况：对端点两侧
(水平方向) 的两条边的斜率进行比较，假如两条边的斜率符号相反，则属于
<span class="math inline"><em>y</em><sup>′</sup></span>
的情况，反之则属于 <span class="math inline"><em>y</em></span>
的情况；当出现 <span class="math inline"><em>y</em><sup>′</sup></span>
的情况时，我们需要将该端点看作两个，这样就相当于 <span
class="math inline"><em>y</em><sup>′</sup></span> 共穿过了 4
个交点，每个交点两两配对，就构成了 3 条线段，这 3
条线段满足“在多边形区域内的线段与在多边形区域外的线段交替出现”的性质，这样就巧妙地将情形转换成了一开始所说的最简单的情况；而对于后者，则是将端点看作是一个交点，这样也能满足该性质。</p>
<p>如何将端点看作是一个点？将端点看作是两个点其实是很好理解的，毕竟端点同时属于两条边，只要将一个端点看作是两条边上不同点就行了。但是如何把一个端点看作是一个点呢？一个可行的办法是，将端点所连接的一条边
(一般是在下面的那条) 在垂直方向上缩短 <span class="math inline">1</span>
个单位，如下图所示：</p>
<p><img src="/img/计算机图形学-04.png" /></p>
<p>上图中展示了两种情况：一个是上线段斜率大于 <span
class="math inline">0</span>，而下线段斜率小于 <span
class="math inline">0</span>；另一个则反一下。但不论是哪种，处理的方法都是：将下端点
<span class="math inline"><em>y</em></span>
轴坐标小的那条线段按照其梯度下降的方向缩短 <span
class="math inline">1</span> 个单位，即沿 y 轴缩短 <span
class="math inline">1</span> 个单位，这样端点就被拆分开来了，原本扫描线
<span class="math inline"><em>y</em></span>
经过一个端点，与两条边相交，现在只是与一条边相交，则不存在端点的问题了，但相应地，由于缩短了下线段的长度，下线段的上端点应当跑到扫描线
<span class="math inline"><em>y</em> − 1</span> 上。</p>
<p>然后来解决第二个问题，如何快速求解扫描线与多边形的交点？请看下图：</p>
<p><img src="/img/计算机图形学-05.png" /></p>
<p>图中展示了两条扫描线 <span
class="math inline"><em>y</em><sub><em>k</em></sub></span> 和 <span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub></span>，两条扫描线相邻，所以有
<span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + 1</span>.
设 <span class="math inline"><em>y</em><sub><em>k</em></sub></span>
与多边形的一个交点为 <span
class="math inline">(<em>x</em><sub><em>k</em></sub>,<em>y</em><sub><em>k</em></sub>)</span>，则在下一刻，也就是在
<span class="math inline"><em>y</em><sub><em>k</em> + 1</sub></span>
中，它将变动到坐标 <span
class="math inline">(<em>x</em><sub><em>k</em> + 1</sub>,<em>y</em><sub><em>k</em> + 1</sub>)</span>
上。在 <a href="计算机图形学.md#01%20画线算法">画线算法</a>
中我们已经讨论了增量公式，假设 <span
class="math inline">(<em>x</em><sub><em>k</em></sub>,<em>y</em><sub><em>k</em></sub>)</span>
和 <span
class="math inline">(<em>x</em><sub><em>k</em> + 1</sub>,<em>y</em><sub><em>k</em> + 1</sub>)</span>
所在的直线的斜率为 <span class="math inline"><em>m</em></span>，并且
<span
class="math inline">$m=\frac{y_{k+1}-y_k}{x_{k+1}-x_k}=\frac{1}{x_{k+1}-x_k}$</span>，由于扫描线
<span class="math inline"><em>y</em><sub><em>k</em></sub></span> 和
<span class="math inline"><em>y</em><sub><em>k</em> + 1</sub></span>
的距离为 <span class="math inline">1</span>，所以自然有 <span
class="math inline"><em>y</em><sub><em>k</em> + 1</sub> = <em>y</em><sub><em>k</em></sub> + 1</span>，根据增量公式，就有
<span class="math display">$$
x_{k+1}=x_k+\frac{1}{m}
$$</span>
只要有上一条扫描线的交点的坐标和直线的斜率，就可以直接计算出下一条扫描线与该直线的交点。</p>
<h3 id="算法的执行流程">2.3 算法的执行流程</h3>
<p>为了实现算法，扫描线算法提出了两种数据结构 —— <strong>边表</strong>
(Edge table，简称 ET) 和<strong>活动边表</strong> (Active edge
table，简称
AET)。边表实质上是一个邻接链表，其作用是记录扫描线所经过的<strong>端点</strong>所连接的两条边的信息，并且链表中的每个节点按照线段的<strong>下端点的
y 轴坐标</strong>进行归类 (即下端点的 y
轴坐标相同的放到同一层去)，下图是一个边表的示例：</p>
<p><img src="/img/计算机图形学-06.png" /></p>
<p>其中，链表中的成员属性如下：</p>
<center>
<div alt="three-table">
<table>
<tr>
<th alt="center">
上端点 y 坐标
</th>
<th alt="center">
下端点 x 坐标
</th>
<th alt="center">
线段斜率的倒数
</th>
<th alt="center">
下一条边的地址
</th>
</tr>
</table>
</div>
</center>
<p>以上图中的扫描线 <span
class="math inline"><em>y</em><sub><em>A</em></sub></span>
为例，其经过端点 <span
class="math inline"><em>A</em></span>，该端点连接了边 <span
class="math inline"><em>A</em><em>E</em></span> 和 <span
class="math inline"><em>A</em><em>B</em></span>，由于这两条边的下端点都是
<span
class="math inline"><em>A</em></span>，所以应该将这两条边的信息保存到扫描线
<span class="math inline"><em>y</em><sub><em>A</em></sub></span>
对应的下标位置；在扫描线 <span
class="math inline"><em>y</em><sub><em>c</em></sub></span>
中，它经过端点 <span class="math inline"><em>C</em></span>，由于 <span
class="math inline"><em>C</em></span> 连接的两条边分别位于 <span
class="math inline"><em>y</em><sub><em>C</em></sub></span>
两边，所以应当将 <span class="math inline"><em>C</em><em>D</em></span>
沿 y 轴缩短一个单位，这样就将 <span
class="math inline"><em>C</em></span> 拆分成了两个点 —— <span
class="math inline"><em>C</em></span> 和 <span
class="math inline"><em>C</em><sup>′</sup></span>. 由于 <span
class="math inline"><em>C</em><em>B</em></span> 和 <span
class="math inline"><em>C</em><sup>′</sup><em>D</em></span> 的下端点的
<span class="math inline"><em>y</em></span> 轴坐标不同，只有 <span
class="math inline"><em>C</em><em>B</em></span> 的下端点 y 轴坐标等于
<span
class="math inline"><em>y</em><sub><em>C</em></sub></span>，所以不能将
<span class="math inline"><em>C</em><sup>′</sup><em>D</em></span>
的信息保存到 <span
class="math inline"><em>y</em><sub><em>C</em></sub></span>
中去，而应该保存到 <span
class="math inline"><em>y</em><sub><em>D</em></sub></span> 中。</p>
<p>而活动边表是一个链表，其中的节点所保存的信息如下
(注意比较和边表的区别)：</p>
<center>
<div alt="three-table">
<table>
<tr>
<th alt="center">
上端点 y 坐标
</th>
<th alt="center">
交点 x 坐标
</th>
<th alt="center">
线段斜率的倒数
</th>
<th alt="center">
下一条边的地址
</th>
</tr>
</table>
</div>
</center>
<p>它是一个随扫描线 <span class="math inline"><em>y</em></span>
轴变化而变化的同态表，而且与边表不同的是，边表只记录端点所在的边，活动边表记录的则是扫描线经过的所有边，并且按照交点的
x
坐标大小从小到大排序。那么活动边表是如何得到每个交点的？方法在之前已经介绍过了，初始的活动边表
(空表不计) 中只有端点所连接的两条边的信息 (水平线例外)，例如上图中的
<span class="math inline"><em>y</em><sub><em>A</em></sub></span>，所以在
<span class="math inline"><em>y</em><sub><em>A</em></sub></span>
时刻，活动边表中的信息与边表中 <span
class="math inline"><em>y</em><sub><em>A</em></sub></span>
是一样的，而在 <span
class="math inline"><em>y</em><sub><em>A</em></sub> + 1</span>
时刻，扫描线会与多边形产生两个交点，如何求这两个交点？首先，交点的 y
轴坐标是已知的，就是 <span
class="math inline"><em>y</em><sub><em>A</em></sub> + 1</span>，唯一要求解的其实只有
x 轴的坐标，根据公式 <span
class="math inline">$x_{k+1}=x_k+\frac{1}{m}$</span>，我们可以很轻松地从上一个交点的
x 轴坐标直接计算出当前交点的 x 轴坐标，所以按照此方法更新交点的 x
轴坐标；并且，由于端点的信息在边表中保存了两次，但分别隶属于斜率不同的两条线段，所以原本重叠的端点在下一时刻就分开了，然后根据之前说的“在多边形区域内的线段与在多边形区域外的线段交替出现”的性质，对交点进行两两配对，我们就能得到扫描线
<span class="math inline"><em>y</em><sub><em>A</em></sub> + 1</span>
上处于多边形内部的线段范围。当扫描线扫描到 <span
class="math inline"><em>y</em><sub><em>D</em></sub></span>
时，又要向活动边表中加入新的端点 (2个)；而当扫描线扫描到 <span
class="math inline"><em>y</em><sub><em>E</em></sub></span>
时，有两个交点，<span
class="math inline"><em>即</em><em>在</em> <em>E</em></span>
点重叠的点，即将被丢弃，因为在下一时刻，这个点就不再是交点了，判断的标准就是
<span
class="math inline">$扫描线的y轴坐标\ge上端点的y轴坐标$</span>，只要这一点不再满足，就说明该交点就不再存在了。</p>
<p>限于文字描述，可能上述过程并不是很清楚，更加详细和具体的例子可以参考<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/405105092">【知乎】扫描线填充算法详解</a>这篇文章。</p>
<hr />
<p>》参考：<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/405105092">【知乎】扫描线填充算法详解</a>、<a
target="_blank" rel="noopener" href="https://www.jianshu.com/p/d9be99077c2b">【简书】扫描线算法完全解析</a></p>
<hr />
<h3 id="作业-1">2.4 作业</h3>
<blockquote>
<p>多边形顶点的坐标为 <span
class="math inline">(7,1)、(2,3)、(2,9)、(7,7)、(13,11)、(13,5)</span>
和 <span class="math inline">(7,1)</span>，请写出该多边形的边表
ET，以及活动边表 AET 中内容的变化。</p>
</blockquote>
<p>首先画出该多边形：</p>
<p><img src="/img/计算机图形学-07.png" /></p>
<p>先求出各条边的斜率及其倒数：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">边</th>
<th style="text-align: center;">m</th>
<th style="text-align: center;">1/m</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">AB</td>
<td style="text-align: center;">-2/5</td>
<td style="text-align: center;">-5/2</td>
</tr>
<tr class="even">
<td style="text-align: center;">BC</td>
<td style="text-align: center;">∞</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">CD</td>
<td style="text-align: center;">-2/5</td>
<td style="text-align: center;">-5/2</td>
</tr>
<tr class="even">
<td style="text-align: center;">DE</td>
<td style="text-align: center;">2/3</td>
<td style="text-align: center;">3/2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">EF</td>
<td style="text-align: center;">∞</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">FA</td>
<td style="text-align: center;">2/3</td>
<td style="text-align: center;">3/2</td>
</tr>
</tbody>
</table>
<p>然后开始构造边表，要注意的是，图中的点 B 和点 F
属于特殊端点，需要将其进行拆分，也就是要变成下面这样：</p>
<p><img src="/img/计算机图形学-08.png" /></p>
<p>接下来构造边表：</p>
<p><img src="/img/计算机图形学-09.png" /></p>
<p>接下来开始构造活动边表，我们从 <span
class="math inline"><em>y</em><sub>1</sub></span> 开始：</p>
<p><img src="/img/计算机图形学-10.png" /></p>
<p>我们将 <span class="math inline"><em>y</em><sub>1</sub></span>
对应的边表中的内容加入到活动边表：</p>
<p><img src="/img/计算机图形学-11.png" /></p>
<p>通过该表，我们就能渲染 y 轴坐标为 <span
class="math inline">1</span>，x 轴坐标在 <span
class="math inline">[7,7]</span> 之间的点。接下来我们来看 <span
class="math inline"><em>y</em><sub>2</sub></span>：</p>
<p><img src="/img/计算机图形学-12.png" /></p>
<p>可以看到，<span class="math inline"><em>y</em><sub>2</sub></span>
交分别交 <span
class="math inline"><em>A</em><em>B</em><sup>′</sup></span> 和 <span
class="math inline"><em>A</em><em>F</em><sup>′</sup></span> 于点 <span
class="math inline">(4.5,2)</span> 和 <span
class="math inline">(8.5,2)</span>，活动边表应及时更新这一信息，也就是更新交点的
x 轴坐标，即用原来的加上斜率的倒数：</p>
<p><img src="/img/计算机图形学-13.png" /></p>
<p>通过该表，我们就能渲染 y 轴坐标为 <span
class="math inline">1</span>，x 轴坐标在 <span
class="math inline">[4.5,8.5]</span> 之间的点。接下来看 <span
class="math inline"><em>y</em><sub>3</sub></span> 的情况：</p>
<p><img src="/img/计算机图形学-14.png" /></p>
<p>此时出现了新情况，那就是 <span
class="math inline"><em>y</em><sub>3</sub></span>
经过了一个新端点，将该端点从边表中取出，并按 x
轴的大小从小大到大排序插入活动边表，此外，原本的 <span
class="math inline"><em>B</em><sup>′</sup></span> 由于已低于 <span
class="math inline"><em>y</em><sub>3</sub></span>，所以应当从活动边表中删除：</p>
<p><img src="/img/计算机图形学-15.png" /></p>
<p>之后的步骤是一样的，直到扫描完最高的端点就结束了，故不再赘述，下面直接给出活动边表的变化过程：</p>
<p><img src="/img/计算机图形学-16.png" /></p>
<h2 id="二维变换">03 二维变换</h2>
<h3 id="平移">3.1 平移</h3>
<p>通过将坐标轴加上位移量，可以实现一次<strong>平移</strong>。对二维图像的平移可以转换为对其端点的平移。设某点的坐标为
<span class="math inline">(<em>x</em>,<em>y</em>)</span>，将其 x
轴坐标平移 <span
class="math inline"><em>t</em><sub><em>x</em></sub></span> 个单位，y
轴坐标平移 <span
class="math inline"><em>t</em><sub><em>y</em></sub></span>
个单位，得到新坐标 <span
class="math inline">(<em>x</em>+<em>t</em><sub><em>x</em></sub>,<em>y</em>+<em>t</em><sub><em>y</em></sub>)</span>，记为
<span
class="math inline">(<em>x</em><sup>′</sup>,<em>y</em><sup>′</sup>)</span>，其中，<span
class="math inline"><em>t</em><sub><em>x</em></sub></span> 和 <span
class="math inline"><em>t</em><sub><em>y</em></sub></span>
称为<strong>平移距离</strong>，<span
class="math inline">(<em>t</em><sub><em>x</em></sub>,<em>t</em><sub><em>y</em></sub>)</span>
称为<strong>平移向量</strong>，将它们转换为矩阵形式： <span
class="math display">$$
\begin{aligned}
P=\begin{bmatrix} x \\ y \end{bmatrix},P^\prime=\begin{bmatrix} x^\prime
\\ y^\prime \end{bmatrix},T=\begin{bmatrix} t_x \\ t_y \end{bmatrix}
\end{aligned}
$$</span> 这样就可以用矩阵形式来表示二维平移方程： <span
class="math display"><em>P</em><sup>′</sup> = <em>P</em> + <em>T</em></span></p>
<h3 id="旋转">3.2 旋转</h3>
<p>通过指定<strong>旋转轴</strong>和<strong>旋转角度</strong>，可以实现一次<strong>旋转</strong>。利用三角函数，我们可以得到一个点围绕某个轴旋转后的坐标，以下图为例：</p>
<p><img src="/img/计算机图形学-17.png" /></p>
<p>该图中，长度为 <span class="math inline"><em>r</em></span>
的线段围绕原点逆时针旋转角度 <span
class="math inline"><em>θ</em></span>，与 <span
class="math inline"><em>x</em></span> 轴所成角度由 <span
class="math inline"><em>ϕ</em></span> 变成 <span
class="math inline"><em>ϕ</em> + <em>θ</em></span>，上端点 <span
class="math inline">(<em>x</em>,<em>y</em>)</span> 移动至 <span
class="math inline">(<em>x</em><sup>′</sup>,<em>y</em><sup>′</sup>)</span>，可以得到以下关系：
<span class="math display">$$
\begin{aligned}
&amp;x^\prime=r\cos(\phi+\theta)=r\cos\phi\cos\theta-r\sin\phi\sin\theta\\
&amp;y^\prime=r\sin(\phi+\theta)=r\cos\phi\sin\theta+r\sin\phi\cos\theta
\end{aligned}
$$</span> 原本的坐标满足以下关系： <span class="math display">$$
\begin{aligned}
&amp;x=r\cos\phi\\
&amp;y=r\sin\phi
\end{aligned}
$$</span> 将其带入之前的式子就可以得到： <span class="math display">$$
\begin{aligned}
&amp;x^\prime=x\cos\theta-y\sin\theta\\
&amp;y^\prime=x\sin\theta+y\cos\theta
\end{aligned}
$$</span> 同样，如果我们把上面的信息转换为矩阵： <span
class="math display">$$
\begin{aligned}
P=\begin{bmatrix} x \\ y \end{bmatrix},P^\prime=\begin{bmatrix} x^\prime
\\ y^\prime \end{bmatrix}=\begin{bmatrix} x\cos\theta-y\sin\theta \\
x\sin\theta+y\cos\theta \end{bmatrix},R=\begin{bmatrix} \cos\theta &amp;
-\sin\theta \\ \sin\theta &amp; \cos\theta \end{bmatrix}
\end{aligned}
$$</span> 其中，<span class="math inline"><em>P</em><sup>′</sup></span>
就被称为<strong>旋转矩阵</strong>，于是就可以得到矩阵形式的二维旋转方程：
<span
class="math display"><em>P</em><sup>′</sup> = <em>R</em><em>P</em></span>
上例展示的是以原点为中心旋转的情况，如果是以任意坐标 <span
class="math inline">(<em>x</em><sub><em>r</em></sub>,<em>y</em><sub><em>r</em></sub>)</span>
作为旋转中心，则式子将会发生下面的变化： <span class="math display">$$
\begin{aligned}
&amp;x^\prime-x_r=(x-x_r)\cos\theta-(y-y_r)\sin\theta\Rightarrow
x^\prime=x_r+(x-x_r)\cos\theta-(y-y_r)\sin\theta\\
&amp;y^\prime-y_r=(x-x_r)\sin\theta+(y-y_r)\cos\theta\Rightarrow
y^\prime=y_r+(x-x_r)\sin\theta+(y-y_r)\cos\theta
\end{aligned}
$$</span> 以上就是通用的二维旋转方程。</p>
<h3 id="缩放">3.3 缩放</h3>
<p>改变一个图形的大小可以使用<strong>缩放</strong>。缩放的本质其实就是在原本坐标的基础上，给横纵坐标分别乘上一个<strong>缩放系数</strong>
<span class="math inline"><em>s</em><sub><em>x</em></sub></span> 和
<span
class="math inline"><em>x</em><sub><em>y</em></sub></span>，于是有公式：
<span class="math display">$$
\begin{aligned}
&amp;x^\prime=x·s_x\\
&amp;y^\prime=y·s_y
\end{aligned}
$$</span> 同样，我们将其化为矩阵形式： <span class="math display">$$
\begin{aligned}
\begin{bmatrix} x^\prime \\ y^\prime \end{bmatrix}=\begin{bmatrix} s_x
&amp; 0 \\ 0 &amp; s_y \end{bmatrix}·\begin{bmatrix} x \\ y
\end{bmatrix}
\end{aligned}
$$</span> 也可以表示为： <span
class="math display"><em>P</em><sup>′</sup> = <em>S</em> · <em>P</em></span>
其中，<span class="math inline"><em>S</em></span>
称为<strong>缩放矩阵</strong>。可以赋予 <span
class="math inline"><em>s</em><sub><em>x</em></sub></span> 和 <span
class="math inline"><em>s</em><sub><em>y</em></sub></span> 任意正值，当
<span class="math inline"><em>s</em><sub><em>x</em></sub></span> 或
<span class="math inline"><em>s</em><sub><em>y</em></sub></span>
的值大于 <span class="math inline">0</span> 的时候则是放大对象；当 <span
class="math inline"><em>s</em><sub><em>x</em></sub></span> 或 <span
class="math inline"><em>s</em><sub><em>y</em></sub></span> 的值小于
<span class="math inline">0</span> 的时候则是缩小对象。当 <span
class="math inline"><em>s</em><sub><em>x</em></sub> = <em>s</em><sub><em>y</em></sub></span>
的时候，对象的长和宽都缩放一样的比例，这种缩放称为<strong>一致缩放</strong>；反之，就是<strong>差值缩放</strong>。同时，还可以给
<span class="math inline"><em>s</em><sub><em>x</em></sub></span> 和
<span class="math inline"><em>s</em><sub><em>y</em></sub></span>
赋予负值，此时不仅会改变图像的尺寸，还会使其相对于一个或多个轴反射。</p>
<p>一件有意思的事情是，当使用上述公式对图像进行缩放时，如果 <span
class="math inline"><em>s</em><sub><em>x</em></sub>, <em>s</em><sub><em>y</em></sub> &lt; 1</span>，图像将会朝靠近原点的方向缩小；如果
<span
class="math inline"><em>s</em><sub><em>x</em></sub>, <em>s</em><sub><em>y</em></sub> &gt; 1</span>，图像将会朝原理原点的方向放大。也就是说，缩放操作不仅导致图像被缩放，还会导致图像被重定位。我们可以选择一个缩放后位置不变的点，称为<strong>固定点</strong>，来控制对象缩放的位置，使其不再向原点缩放。设固定点坐标为
<span
class="math inline">(<em>x</em><sub><em>f</em></sub>,<em>y</em><sub><em>f</em></sub>)</span>，得到下面的公式：
<span class="math display">$$
\begin{aligned}
x^\prime-x_f=(x-x_f)·s_x,\quad y^\prime-y_f=(y-y_f)·s_y
\end{aligned}
$$</span> 重新整理上述公式可得： <span class="math display">$$
\begin{aligned}
&amp;x^\prime=x·s_x+x_f(1-s_x)\\
&amp;y^\prime=y·s_y+y_f(1-s_y)
\end{aligned}
$$</span></p>
<h3 id="齐次坐标">3.4 齐次坐标</h3>
<p>我们可以尝试将平移、旋转、缩放的公式写到一起，就有： <span
class="math display"><em>P</em><sup>′</sup> = <em>M</em><sub>1</sub> · <em>P</em> + <em>M</em><sub>2</sub></span>
<span class="math inline"><em>M</em><sub>1</sub></span>
是旋转矩阵和缩放矩阵的乘积，是一个 2*2 的矩阵，<span
class="math inline"><em>M</em><sub>2</sub></span> 是平移矩阵，其大小为
1*2。对于纯平移操作，<span
class="math inline"><em>M</em><sub>1</sub></span>
是单位矩阵；对于纯旋转或缩放操作，<span
class="math inline"><em>M</em><sub>2</sub></span>
并不是零矩阵，而是提供了旋转中心和固定点的增量值。</p>
<p>出于提升性能的需要，我们希望尽可能使用矩阵乘法，消除矩阵加法，并且避免复合操作的中间过程，直接通过一个公式导出最终结果，为此，我们需要引入<strong>齐次坐标</strong>。齐次坐标是一种用
<span class="math inline"><em>N</em> + 1</span> 个数字来表示 <span
class="math inline"><em>N</em></span>
维坐标系的方法，对于二维坐标，其一般形式为 <span
class="math inline">(<em>x</em>,<em>y</em>,<em>w</em>)</span>，用于表示二维坐标
<span class="math inline">$(\frac xh,\frac yh)$</span>，其中，<span
class="math inline"><em>h</em></span>
称为<strong>齐次参数</strong>，一般为 <span
class="math inline">1</span>，对于不是 <span
class="math inline">1</span> 的齐次坐标，我们需要手动将其化为 <span
class="math inline">1</span>。</p>
<blockquote>
<p>齐次坐标对几何的影响十分深远，有了齐次坐标，我们甚至可以表示一个无穷远处的点，只需要将齐次参数设为
<span class="math inline">0</span>
即可。教材只介绍了齐次坐标的使用，并未介绍齐次坐标的原理，感兴趣可以自行了解。</p>
</blockquote>
<p>在引入了齐次坐标之后，我们可以重新表示二维坐标下的平移矩阵： <span
class="math display">$$
T=\begin{bmatrix} 1 &amp; 0 &amp; x_t \\ 0 &amp; 1 &amp; y_t \\ 0 &amp;
0 &amp; 1 \end{bmatrix}
$$</span> 二维平移方程可改为： <span class="math display">$$
\begin{bmatrix} x^\prime \\ y^\prime \\ 1 \end{bmatrix}=\begin{bmatrix}
1 &amp; 0 &amp; x_t \\ 0 &amp; 1 &amp; y_t \\ 0 &amp; 0 &amp; 1
\end{bmatrix}·\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}
$$</span>
这样，我们就成功地将平移操作转换为了矩阵乘法。类似地，我们也可以二维旋转公式转换为矩阵形式：
<span class="math display">$$
\begin{bmatrix} x^\prime \\ y^\prime \\ 1 \end{bmatrix}=\begin{bmatrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\ \sin\theta &amp; \cos\theta
&amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} x \\ y \\ 1
\end{bmatrix}
$$</span> 二维缩放公式： <span class="math display">$$
\begin{bmatrix} x^\prime \\ y^\prime \\ 1 \end{bmatrix}=\begin{bmatrix}
s_x &amp; 0 &amp; 0 \\ 0 &amp; s_y &amp; 0 \\ 0 &amp; 0 &amp; 1
\end{bmatrix}·\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}
$$</span></p>
<h3 id="逆变换">3.5 逆变换</h3>
<p>如果我们需要将一个进行了平移后的对象还原回去，那就需要进行逆操作，逆平移矩阵为：
<span class="math display">$$
T^{-1}=\begin{bmatrix} 1 &amp; 0 &amp; -t_x \\ 0 &amp; 1 &amp; -t_y \\ 0
&amp; 0 &amp; 1 \end{bmatrix}
$$</span>
对于逆旋转操作，其实现方式只是将其旋转角度改为负值，显然这只会对 <span
class="math inline">sin </span> 产生影响： <span class="math display">$$
R^{-1}=\begin{bmatrix} \cos\theta &amp; \sin\theta &amp; 0 \\
-\sin\theta &amp; \cos\theta &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span> 而对于逆缩放，只需要对缩放系数取倒数即可： <span
class="math display">$$
S^{-1}=\begin{bmatrix} \frac{1}{s_x} &amp; 0 &amp; 0 \\ 0 &amp;
\frac{1}{s_y} &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span></p>
<h3 id="复合变换">3.6 复合变换</h3>
<p><span class="math display">$$
P^\prime=M_1·M_2...M_n·P\\
\Downarrow\\
P^\prime=M·P
$$</span></p>
<p>在将所有操作都统一为矩阵乘法之后，我们可以单用一个矩阵 <span
class="math inline"><em>M</em></span>
来直接表示所有操作的复合，关于复合变换其实没什么好讲的，但这里有几条性质值得关注一下。</p>
<ol type="1">
<li>复合平移变换：<span
class="math inline"><em>T</em>(<em>t</em><sub>1<em>x</em></sub>,<em>t</em><sub>1<em>y</em></sub>) · <em>T</em>(<em>t</em><sub>2<em>x</em></sub>,<em>t</em><sub>2<em>y</em></sub>) = <em>T</em>(<em>t</em><sub>1<em>x</em></sub>+<em>t</em><sub>2<em>x</em></sub>,<em>t</em><sub>1<em>y</em></sub>+<em>t</em><sub>2<em>y</em></sub>)</span></li>
</ol>
<p><span class="math display">$$
\begin{bmatrix} 1 &amp; 0 &amp; t_{1x} \\ 0 &amp; 1 &amp; t_{1y} \\ 0
&amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} 1 &amp; 0 &amp; t_{2x} \\
0 &amp; 1 &amp; t_{2y} \\ 0 &amp; 0 &amp; 1
\end{bmatrix}=\begin{bmatrix} 1 &amp; 0 &amp; t_{1x}+t_{2x} \\ 0 &amp; 1
&amp; t_{1y}+t_{2y} \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span></p>
<ol start="2" type="1">
<li>复合旋转变换：<span
class="math inline"><em>R</em>(<em>θ</em><sub>1</sub>) · <em>R</em>(<em>θ</em><sub>2</sub>) = <em>R</em>(<em>θ</em><sub>1</sub>+<em>θ</em><sub>2</sub>)</span></li>
</ol>
<p><span class="math display">$$
\begin{bmatrix} \cos\theta_1 &amp; -\sin\theta_1 &amp; 0 \\ \sin\theta_1
&amp; \cos\theta_1 &amp; 0 \\ 0 &amp; 0 &amp; 1
\end{bmatrix}·\begin{bmatrix} \cos\theta_2 &amp; -\sin\theta_2 &amp; 0
\\ \sin\theta_2 &amp; \cos\theta_2 &amp; 0 \\ 0 &amp; 0 &amp; 1
\end{bmatrix}=\begin{bmatrix} \cos(\theta_1+\theta_2) &amp;
-\sin(\theta_1+\theta_2) &amp; 0 \\ \sin(\theta_1+\theta_2) &amp;
\cos(\theta_1+\theta_2) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span></p>
<ol start="3" type="1">
<li>复合缩放变换：<span
class="math inline"><em>S</em>(<em>s</em><sub>1<em>x</em></sub>,<em>s</em><sub>1<em>y</em></sub>) · <em>S</em>(<em>s</em><sub>2<em>x</em></sub>,<em>s</em><sub>2<em>y</em></sub>) = <em>S</em>(<em>s</em><sub>1<em>x</em></sub>·<em>s</em><sub>2<em>x</em></sub>,<em>s</em><sub>1<em>y</em></sub>·<em>s</em><sub>2<em>y</em></sub>)</span></li>
</ol>
<p><span class="math display">$$
\begin{bmatrix} s_{1x} &amp; 0 &amp; 0 \\ 0 &amp; s_{1y} &amp; 0 \\ 0
&amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} s_{2x} &amp; 0 &amp; 0 \\
0 &amp; s_{2y} &amp; 0 \\ 0 &amp; 0 &amp; 1
\end{bmatrix}=\begin{bmatrix} s_{1x}·s_{2x} &amp; 0 &amp; 0 \\ 0 &amp;
s_{1y}·s_{2y} &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span></p>
<ol start="4" type="1">
<li><p>基准点旋转</p>
<p>当工具包只支持围绕原点旋转时，我们可以使用如下方法实现围绕任意基准点
<span
class="math inline">(<em>x</em><sub><em>r</em></sub>,<em>y</em><sub><em>r</em></sub>)</span>
旋转：</p>
<ul>
<li>通过平移使对象的基准点回到原点</li>
<li>对对象进行旋转</li>
<li>通过逆平移使对象的基准点回到原来位置</li>
</ul>
<p>上述过程的图示如下：</p></li>
</ol>
<p><img src="/img/计算机图形学-18.png" /></p>
<p>复合变换矩阵表示为： <span class="math display">$$
\begin{bmatrix} 1 &amp; 0 &amp; x_{r} \\ 0 &amp; 1 &amp; y_{r} \\ 0
&amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} \cos\theta &amp;
-\sin\theta &amp; 0 \\ \sin\theta &amp; \cos\theta &amp; 0 \\ 0 &amp; 0
&amp; 1 \end{bmatrix}·\begin{bmatrix} 1 &amp; 0 &amp; -x_{r} \\ 0 &amp;
1 &amp; -y_{r} \\ 0 &amp; 0 &amp; 1 \end{bmatrix}=\begin{bmatrix}
\cos\theta &amp; -\sin\theta &amp; x_{r}(1-\cos\theta)+y_{r}\sin_\theta
\\ \sin\theta &amp; \cos\theta &amp;
y_{r}(1-\cos\theta)-x_{r}\sin_\theta \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span></p>
<ol start="5" type="1">
<li><p>基准点缩放</p>
<p>和围绕基准点旋转的方法一样，都是先将基准点调整至原点，缩放，然后再调整回去。复合变换矩阵表示为：</p></li>
</ol>
<p><span class="math display">$$
\begin{bmatrix} 1 &amp; 0 &amp; x_{r} \\ 0 &amp; 1 &amp; y_{r} \\ 0
&amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} s_x &amp; 0 &amp; 0 \\ 0
&amp; s_y &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} 1
&amp; 0 &amp; -x_{r} \\ 0 &amp; 1 &amp; -y_{r} \\ 0 &amp; 0 &amp; 1
\end{bmatrix}=\begin{bmatrix} s_x &amp; 0 &amp; x_f(1-s_x) \\ 0 &amp;
s_y &amp; y_f(1-s_y) \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span></p>
<ol start="6" type="1">
<li><p>定向缩放</p>
<p>正常的 <span
class="math inline"><em>s</em><sub><em>x</em></sub></span> 和 <span
class="math inline"><em>s</em><sub><em>y</em></sub></span> 沿 x 轴和 y
轴缩放对象，但如果希望沿其他轴线缩放，可以使用类似基准点缩放的方法，即先将缩放轴线调整至与
x 轴或 y 轴重合再进行缩放，最后再调整回来。如下图所示：</p>
<p><img src="/img/计算机图形学-20.png" /></p>
<p>复合变换矩阵表示为：</p></li>
</ol>
<p><span class="math display">$$
R^{-1}(\theta)·S(s_1,s_2)·R(\theta)=\begin{bmatrix}
s_1\cos^2\theta+s_2\sin^2\theta &amp; (s_2-s_1)\cos\theta\sin\theta
&amp; 0 \\ (s_2-s_1)\cos\theta\sin\theta &amp;
s_1\sin^2\theta+s_2\cos^2\theta &amp; 0 \\ 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</span></p>
<p>另外，按照矩阵乘法的结合性质，<span
class="math inline"><em>M</em><sub>1</sub> · <em>M</em><sub>2</sub> · <em>M</em><sub>3</sub> = (<em>M</em><sub>1</sub>·<em>M</em><sub>2</sub>) · <em>M</em><sub>3</sub> = <em>M</em><sub>1</sub> · (<em>M</em><sub>2</sub>·<em>M</em><sub>3</sub>)</span>；但是，变换积一般不可交换顺序，也就是
<span
class="math inline"><em>M</em><sub>1</sub> · <em>M</em><sub>2</sub> ≠ <em>M</em><sub>2</sub> · <em>M</em><sub>1</sub></span>，除非所进行的复合变换属于同种变换。</p>
<h3 id="错切">3.7 错切</h3>
<p>错切是指，将某一点沿 x 轴 (或 y 轴) 方向移动其与 y 轴 (或 x 轴)
距离的某一倍数，定义错切参数 <span
class="math inline">sh<sub><em>x</em></sub></span>、<span
class="math inline">sh<sub><em>y</em></sub></span>，则有： <span
class="math display">$$
\begin{aligned}
x^\prime=x+y·\operatorname{sh}_x\\
y^\prime=y+x·\operatorname{sh}_y
\end{aligned}
$$</span> 错切的变换矩阵为： <span class="math display">$$
\begin{bmatrix} 1 &amp; \operatorname{sh}_{x} &amp; 0 \\
\operatorname{sh}_{y} &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{bmatrix}
$$</span> 如果想做相对于其他参考线的错切，可以使用下面的变换矩阵： <span
class="math display">$$
\begin{bmatrix} 1 &amp; \operatorname{sh}_{x} &amp;
-\operatorname{sh}_x·y_{ref} \\ \operatorname{sh}_{y} &amp; 1 &amp;
-\operatorname{sh}_y·x_{ref} \\ 0 &amp; 0 &amp; 1\end{bmatrix}
$$</span> 这样，错切方程将会变为： <span class="math display">$$
\begin{aligned}
&amp;x^\prime=x+\operatorname{sh}_{x}(y-y_{ref})\\
&amp;y^\prime=y+\operatorname{sh}_y(x-x_{ref})
\end{aligned}
$$</span></p>
<h3 id="作业-2">3.8 作业</h3>
<blockquote>
<p>将正方形 <span
class="math inline"><em>A</em>(0,0)、<em>B</em>(0,1)、<em>C</em>(1,1)、<em>D</em>(1,0)</span>，放大
<span class="math inline">2</span> 倍，并保持 <span
class="math inline"><em>C</em>(1,1)</span>
位置不变，请给出变换矩阵以及对应的正方形顶点坐标。</p>
</blockquote>
<p>将正方形 <span
class="math inline"><em>A</em><em>B</em><em>C</em><em>D</em></span> 放大
<span class="math inline">2</span> 倍且要保持 <span
class="math inline"><em>C</em></span> 点位置不变，即以 <span
class="math inline"><em>C</em></span> 点为基准点进行缩放，变换矩阵为：
<span class="math display">$$
M=\begin{bmatrix} 1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\ 0 &amp; 0
&amp; 1 \end{bmatrix}·\begin{bmatrix} 2 &amp; 0 &amp; 0 \\ 0 &amp; 2
&amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} 1 &amp; 0
&amp; -1 \\ 0 &amp; 1 &amp; -1 \\ 0 &amp; 0 &amp; 1
\end{bmatrix}=\begin{bmatrix} 2 &amp; 0 &amp; -1 \\ 0 &amp; 2 &amp; -1
\\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span> 对答案进行检验： <span class="math display">$$
\begin{aligned}
&amp;A^\prime=\begin{bmatrix} 2 &amp; 0 &amp; -1 \\ 0 &amp; 2 &amp; -1
\\ 0 &amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} 0
\\ 0 \\ 1 \end{bmatrix}=\begin{bmatrix} -1 \\ -1 \\ 1 \end{bmatrix}\\
&amp;B^\prime=\begin{bmatrix} 2 &amp; 0 &amp; -1 \\ 0 &amp; 2 &amp; -1
\\ 0 &amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} 0
\\ 1 \\ 1 \end{bmatrix}=\begin{bmatrix} -1 \\ 1 \\ 1 \end{bmatrix}\\
&amp;C^\prime=\begin{bmatrix} 2 &amp; 0 &amp; -1 \\ 0 &amp; 2 &amp; -1
\\ 0 &amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} 1 \\ 1 \\ 1
\end{bmatrix}=\begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix}\\
&amp;D^\prime=\begin{bmatrix} 2 &amp; 0 &amp; -1 \\ 0 &amp; 2 &amp; -1
\\ 0 &amp; 0 &amp; 1 \end{bmatrix}·\begin{bmatrix} 1
\\ 0 \\ 1 \end{bmatrix}=\begin{bmatrix} 1 \\ -1 \\ 1 \end{bmatrix}
\end{aligned}
$$</span> 画出图像：</p>
<p><img src="/img/计算机图形学-19.png" /></p>
<hr />
<blockquote>
<p>正方形 <span
class="math inline"><em>A</em>(0,0)、<em>B</em>(0,1)、<em>C</em>(1,1)、<em>D</em>(1,0)</span>
经过变换后的坐标分别对应为 <span
class="math inline">(0,0)、(0.5,1.5)、(2,2)、(1.5,0.5)</span>。请给出变换矩阵。</p>
</blockquote>
<p>画出变换之后的图像可以发现，是由原图像沿右对角线定向缩放得到的，此时应该设定
<span class="math inline"><em>θ</em> = 45°</span>，<span
class="math inline"><em>s</em><sub><em>x</em></sub> = 1</span>，<span
class="math inline"><em>s</em><sub><em>y</em></sub> = 2</span>，<span
class="math inline"><em>θ</em></span> 为 <span
class="math inline">45°</span> 是因为对角线想要逆时针旋转到 y 轴需要旋转
<span class="math inline">45°</span>，而 <span
class="math inline"><em>s</em><sub><em>x</em></sub></span> 和 <span
class="math inline"><em>s</em><sub><em>y</em></sub></span>
是如何确定的呢？我们将原图像逆时针旋转 <span
class="math inline">45°</span>
后，计算出每个点的坐标，再将变换后的图像也逆时针旋转 <span
class="math inline">45°</span>，也计算出各点的坐标，然后计算每个轴上缩放的比例即可。计算完比例之后，根据定向缩放的公式，得到：
<span class="math display">$$
M=R^{-1}(45°)·S(1,2)·R(45°)=\begin{bmatrix} 1.5 &amp; 0.5 &amp; 0 \\ 0.5
&amp; 1.5 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}
$$</span>
上面演示的是带公式的方法，还有一种更简单的方法是，利用矩阵<strong>逆运算</strong>：
<span class="math display">$$
\begin{aligned}
&amp;M·\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 1 &amp; 1
&amp; 0 \\ 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}=\begin{bmatrix} 0
&amp; 0.5 &amp; 2 &amp; 1.5 \\ 0 &amp; 1.5 &amp; 2 &amp; 0.5 \\ 1 &amp;
1 &amp; 1 &amp; 1 \end{bmatrix}\\\\
&amp;M=\begin{bmatrix} 0 &amp; 0.5 &amp; 2 &amp; 1.5 \\ 0 &amp; 1.5
&amp; 2 &amp; 0.5 \\ 1 &amp; 1 &amp; 1 &amp; 1
\end{bmatrix}·\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 1
&amp; 1 &amp; 0 \\ 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}^{-1}
\end{aligned}
$$</span> 解得变换矩阵仍然为： <span class="math display">$$
M=\begin{bmatrix} 1.5 &amp; 0.5 &amp; 0 \\ 0.5 &amp; 1.5 &amp; 0 \\ 0
&amp; 0 &amp; 1 \end{bmatrix}
$$</span></p>
<h2 id="样条表示">04 样条表示</h2>
<p>样条是通过一组指定点集而生成平滑曲线的柔性带。通俗来讲，之前学的画线算法解决的是在图形学里画直线的问题，样条表示解决的是在图形学里画曲线的问题。</p>
<p>在计算机图形学中，<strong>样条曲线</strong>指多项式曲线段连接而成的曲线，在每段的边界处满足特定的连续性条件。<strong>样条曲面</strong>可以使用两组样条曲线进行描述。</p>
<h3 id="基本概念">4.1 基本概念</h3>
<h4 id="曲线曲面的表示方法">4.1.1 曲线曲面的表示方法</h4>
<p>曲线曲面的表示有三种：显式、隐式和参数表示。</p>
<p>显式表示就是我们熟知的 <span
class="math inline"><em>y</em> = <em>f</em>(<em>x</em>)</span>
形式，这种形式虽然直观简单，但是显式方程中，一个 x 只能对应一个 y
值，所以显式方程不能表示封闭或多值曲线。</p>
<p>隐式表示的形式是 <span
class="math inline"><em>f</em>(<em>x</em>,<em>y</em>) = 0</span>，隐式方程的优点是易于判断一个点是否在曲线上，缺点是不直观，作图不方便。并且，不论显示还是隐式，都与坐标轴相关，而且有可能会出现斜率无穷大的情形。</p>
<p>为了避免这些问题，可以选择参数方程来表示。假定用 <span
class="math inline"><em>t</em></span> 表示参数，平面参数上任一点 <span
class="math inline">P</span> 可表示为： <span
class="math display"><em>p</em>(<em>t</em>) = [<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>)]</span>
这是二维的情形，如果是在空间里，三维点 <span
class="math inline">P</span> 可表示为： <span
class="math display"><em>p</em>(<em>t</em>) = [<em>x</em>(<em>t</em>), <em>y</em>(<em>t</em>), <em>z</em>(<em>t</em>)]</span>
它等价于笛卡尔分量表示： <span
class="math display"><em>p</em>(<em>t</em>) = <em>x</em>(<em>t</em>)<em>i⃗</em> + <em>y</em>(<em>t</em>)<em>j⃗</em> + <em>z</em>(<em>t</em>)<em>k⃗</em></span>
其中，<span
class="math inline"><em>i⃗</em>、<em>j⃗</em>、<em>k⃗</em></span>
是三个坐标轴上的单位向量。这样，给定一个 <span
class="math inline"><em>t</em></span> 值，就得到曲线上一点的坐标。</p>
<p>假设曲线段对应的参数区间为 <span
class="math inline">[<em>a</em>,<em>b</em>]</span>，即 <span
class="math inline"><em>a</em> ≤ <em>t</em> ≤ <em>b</em></span>，为方便将区间
<span class="math inline">[<em>a</em>,<em>b</em>]</span> 规范化成 <span
class="math inline">[0,1]</span>，参数变换为： <span
class="math display">$$
t^\prime=\frac{t-a}{b-a}
$$</span> 参数曲线一般可写成： <span
class="math display"><em>p</em> = <em>p</em>(<em>t</em>)  <em>t</em> ∈ [0,1]</span>
类似地，可以把曲面表示成为双参数 <span
class="math inline"><em>u</em></span> 和 <span
class="math inline"><em>v</em></span> 的矢量函数： <span
class="math display"><em>p</em>(<em>u</em>,<em>v</em>) = <em>p</em>(<em>x</em>(<em>u</em>,<em>v</em>), <em>y</em>(<em>u</em>,<em>v</em>), <em>z</em>(<em>u</em>,<em>v</em>))  (<em>u</em>,<em>v</em>) ∈ [0,1] × [0,1]</span></p>
<h4 id="曲线曲面的绘制方法">4.1.2 曲线曲面的绘制方法</h4>
<p>在计算数学中，<strong>逼近</strong>通常指用一些性质较好的函数近似表示一些性质不好的函数。在计算机图形学中，逼近继承了这方面的含义。<strong>插值</strong>和<strong>拟合</strong>是两种图形学中常用的曲线曲面的绘制方法，它们体现的思想都可以视为逼近。</p>
<p>方法 1：插值</p>
<p>自由曲线和自由曲面一般通过少数分散的点生成，这些点叫做“型值点”、“样本点”或“控制点”。</p>
<p>给定一组有序的数据点 <span
class="math inline"><em>P</em><sub><em>i</em></sub> (<em>i</em>=0,1,2,...,<em>n</em>)</span>，要求构造一条曲线，顺序通过这些数据点，这一过程称为对这些数据点进行<strong>插值</strong>，所构造的曲线称为<strong>插值曲线</strong>。插值的过程如下所示：</p>
<p><img src="/img/计算机图形学-22.gif" /></p>
<p>插值的目标就是找一个函数 <span
class="math inline"><em>f</em>(<em>x</em>)</span>，使得该函数图像刚刚好穿过所有的点。如果该函数是一个形如
<span
class="math inline"><em>f</em>(<em>x</em>) = <em>a</em><em>x</em> + <em>b</em></span>
的线性函数，则称为<strong>线性插值</strong>，这种情况下其实是拿一条直线去近似一条曲线；如果该函数是一个形如
<span
class="math inline"><em>f</em>(<em>x</em>) = <em>a</em><em>x</em><sup>2</sup> + <em>b</em><em>x</em> + <em>c</em></span>
的抛物线函数，则称为<strong>抛物线插值</strong>。</p>
<p>方法 2：拟合</p>
<p>在实际实验中，这些控制点也难免会有误差，也就是说控制点的位置也不一定准确，所以没必要使曲线一定要穿过每一个控制点。</p>
<p>构造一条曲线，使之在某种意义下最接近给定的数据点（但未必通过这些点），所构造的曲线为<strong>拟合曲线</strong>，这一过程也就称为<strong>拟合</strong>。其过程如下所示：</p>
<p><img src="/img/计算机图形学-23.gif" /></p>
<p>可以发现，由这四个控制点所绘制出的曲线并没有完全穿过所有控制点，而是只穿过了起始点和终止点。</p>
<p>一般，我们将连接有一定次序控制点的直线序列称为<strong>控制多边形</strong>或<strong>特征多边形</strong>。</p>
<h3 id="hermite-曲线">4.2 Hermite 曲线</h3>
<p>Hermite
曲线是一种<strong>插值</strong>曲线，通过给定的<strong>控制点</strong>和<strong>切线</strong>来定义曲线的形状。</p>
<p>参数曲线有代数形式和几何形式。接下来以三次参数曲线为例，讨论参数曲线的代数和几何形式。参数曲线的代数形式如下：
<span class="math display">$$
\left\{
\begin{array}{}
x(t)=a_{3x}t^3+a_{2x}t^2+a_{1x}t+a_{0x}\\
y(t)=a_{3y}t^3+a_{2y}t^2+a_{1y}t+a_{0y}\\
z(t)=a_{3z}t^3+a_{2z}t^2+a_{1z}t+a_{0z}\\
\end{array}
\right.
\quad\quad
t\in[0,1]
$$</span> 将上述代数式写成矢量式就是： <span
class="math display"><em>P</em>(<em>t</em>) = <em>a</em><sub>3</sub><em>t</em><sup>3</sup> + <em>a</em><sub>2</sub><em>t</em><sup>2</sup> + <em>a</em><sub>1</sub><em>t</em> + <em>a</em><sub>0</sub>  <em>t</em> ∈ [0,1]</span>
在上式中，<span
class="math inline"><em>a</em><sub>3</sub>、<em>a</em><sub>2</sub>、<em>a</em><sub>1</sub>、<em>a</em><sub>0</sub></span>
是参数曲线的系数，但不是常数而是向量。代数形式的缺点在于，倘若系数被改变，曲线会如何变化是不清楚的。</p>
<p>参数曲线的几何形式是利用一条曲线<strong>端点</strong>的几何性质来刻画一条曲线。所谓端点的几何性质，就是指曲线的端点位置、切向量、各阶导数等端点的信息。对于三次参数曲线，可以用其端点的<strong>位矢</strong>
<span class="math inline"><em>P</em>(0)、<em>P</em>(1)</span>
和<strong>切矢</strong> <span
class="math inline"><em>P</em><sup>′</sup>(0)、<em>P</em><sup>′</sup>(1)</span>
描述，我们将这四个量简记为 <span
class="math inline"><em>P</em><sub>0</sub>、<em>P</em><sub>1</sub>、<em>P</em><sub>0</sub><sup>′</sup>、<em>P</em><sub>1</sub><sup>′</sup></span>。我们将这四个量分别代入参数曲线的矢量式和其一阶导，也就是将
<span class="math inline"><em>t</em> = 0, 1</span> 代入，得到： <span
class="math display">$$
\left\{
\begin{array}{}
\begin{aligned}
&amp;P_0=a_0\\
&amp;P_1=a_3+a_2+a_1+a_0\\
&amp;P_0^\prime=a_1\\
&amp;P_1^\prime=3a_3+2a_2+a_1
\end{aligned}
\end{array}
\right.
$$</span> 于是就能得到： <span class="math display">$$
\left\{
\begin{array}{}
\begin{aligned}
&amp;a_0=P_0\\
&amp;a_1=P^\prime_0\\
&amp;a_2=-3P_0+3P_1-2P_0^\prime-P_1^\prime\\
&amp;a_3=2P_0-2P_1+P_0^\prime+P_1^\prime
\end{aligned}
\end{array}
\right.
$$</span> 将上面的解代会到原式中，就能得到参数曲线的几何形式： <span
class="math display"><em>P</em>(<em>t</em>) = (2<em>t</em><sup>3</sup>−3<em>t</em><sup>2</sup>+1)<em>P</em><sub>0</sub> + (−2<em>t</em><sup>3</sup>+3<em>t</em><sup>2</sup>)<em>P</em><sub>1</sub> + (<em>t</em><sup>3</sup>−2<em>t</em><sup>2</sup>−<em>t</em>)<em>P</em><sub>0</sub><sup>′</sup> + (<em>t</em><sup>3</sup>−<em>t</em><sup>2</sup>)<em>P</em><sub>1</sub><sup>′</sup></span>
我们令： <span class="math display">$$
\begin{aligned}
&amp;F_0(t)=2t^3-3t^2+1\\
&amp;F_1(t)=-2t^3+3t^2\\
&amp;G_0(t)=t^3-2t^2-t\\
&amp;G_1(t)=t^3-t^2\\
\end{aligned}
$$</span> 再代入原来的方程： <span
class="math display"><em>P</em>(<em>t</em>) = <em>F</em><sub>0</sub><em>P</em><sub>0</sub> + <em>F</em><sub>1</sub><em>P</em><sub>1</sub> + <em>G</em><sub>0</sub><em>P</em><sub>0</sub><sup>′</sup> + <em>G</em><sub>1</sub><em>P</em><sub>1</sub><sup>′</sup>    <em>t</em> ∈ [0,1]</span>
其中，<span
class="math inline"><em>P</em><sub>0</sub>、<em>P</em><sub>1</sub>、<em>P</em><sub>0</sub><sup>′</sup>、<em>P</em><sub>1</sub><sup>′</sup></span>
是几何系数，<span
class="math inline"><em>F</em><sub>0</sub>、<em>F</em><sub>1</sub>、<em>G</em><sub>0</sub>、<em>G</em><sub>1</sub></span>
称为调和函数（或混合函数）。上式就是三次 Hermite 曲线的几何形式。</p>
<h3 id="bezier-曲线">4.3 Bezier 曲线</h3>
<h4 id="定义">4.3.1 定义</h4>
<p>针对 Bezier 曲线，给定空间 <span class="math inline">n+1</span>
个点的位置矢量 <span
class="math inline">P<sub>i</sub> (i=0,1,2,...,n)</span>，则 Bezier
曲线段的参数方程表示如下：</p>
<p><span class="math display">$$
p(t)=\sum\limits_{i=0}^{n}P_iB_{i,n}(t)\quad t\in[0,1]
$$</span></p>
<p>其中，<span
class="math inline"><em>P</em><sub><em>i</em></sub>(<em>x</em><sub><em>i</em></sub>,<em>y</em><sub><em>i</em></sub>,<em>z</em><sub><em>i</em></sub>), <em>i</em> = 1, 2, ..., <em>n</em></span>
是控制多边形的 <span class="math inline">n+1</span>
个顶点，即构成该曲线的特征多边形，<span
class="math inline"><em>B</em><sub><em>i</em>, <em>n</em></sub>(<em>t</em>)</span>
是 Bernstein 基函数，有如下形式：</p>
<p><span class="math display">$$
B_{i,n}(t)=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=C_n^it^{i(1-t)^{n-1}}\quad(i=0,1,...,n)
$$</span></p>
<p><span class="math inline">$\sum_{i=0}^{n}B_{i,n}(t)$</span>
恰好是二项式 <span
class="math inline">[<em>t</em>+(1−<em>t</em>)]<sup><em>n</em></sup></span>
的展开式！</p>
<h4 id="一次-bezier-曲线">4.3.2 一次 Bezier 曲线</h4>
<p>当 <span class="math inline">n=1</span> 的时候，只有两个控制点 <span
class="math inline">P<sub>0</sub></span> 和 <span
class="math inline">P<sub>1</sub></span>，Bezier 多项式是一次多项式：
<span class="math display">$$
p(t)=\sum_{i=0}^{1}P_iB_{i,1}(t)=P_0B_{0,1}(t)+P_1B_{1,1}(t)
$$</span> 直接代入 Bernstein 方程求 <span
class="math inline"><em>B</em><sub>0, 1</sub></span> 和 <span
class="math inline"><em>B</em><sub>1, 1</sub></span>： <span
class="math display">$$
\begin{aligned}
&amp;B_{0,1}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{1!}{0!(1-0)!}t^0(1-t)^{1-0}=1-t\\
&amp;B_{1,1}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{1!}{1!(1-1)!}t^1(1-t)^{1-1}=t\\
\end{aligned}
$$</span> 所以，化简后的一次 Bezier 曲线的方程为： <span
class="math display"><em>p</em>(<em>t</em>) = (1−<em>t</em>)<em>P</em><sub>0</sub> + <em>t</em><em>P</em><sub>1</sub></span>
这刚刚好是连接起点 <span
class="math inline"><em>P</em><sub>0</sub></span> 和终点 <span
class="math inline"><em>P</em><sub>1</sub></span> 的直线段。</p>
<h4 id="二次-bezier-曲线">4.3.3 二次 Bezier 曲线</h4>
<p>当 <span class="math inline">n=2</span> 时，有 <span
class="math inline">3</span> 个控制点 <span
class="math inline">P<sub>0</sub></span>、<span
class="math inline">P<sub>1</sub></span> 和 <span
class="math inline">P<sub>2</sub></span>，Bezier 多项式是二次多项式：
<span class="math display">$$
p(t)=\sum_{i=0}^{2}P_iB_{i,2}(t)=P_0B_{0,2}(t)+P_1B_{1,2}(t)+P_2B_{2,2}(t)
$$</span> 求解 <span
class="math inline"><em>B</em><sub>0, 2</sub></span>、<span
class="math inline"><em>B</em><sub>1, 2</sub></span> 和 <span
class="math inline"><em>B</em><sub>2, 2</sub></span>： <span
class="math display">$$
\begin{aligned}
&amp;B_{0,2}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{2!}{0!(2-0)!}t^0(1-t)^{2-0}=(1-t)^2\\
&amp;B_{1,2}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{2!}{1!(2-1)!}t^1(1-t)^{2-1}=2t(1-t)\\
&amp;B_{2,2}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{2!}{2!(2-2)!}t^2(1-t)^{2-2}=t^2\\
\end{aligned}
$$</span> 最后化简得到的二次 Bezier 曲线的方程为： <span
class="math display"><em>p</em>(<em>t</em>) = (1−<em>t</em>)<sup>2</sup><em>P</em><sub>0</sub> + 2<em>t</em>(1−<em>t</em>)<em>P</em><sub>1</sub> + <em>t</em><sup>2</sup><em>P</em><sub>2</sub></span>
二次 Bezier 曲线为抛物线，其矩阵形式为： <span class="math display">$$
p(t)=\left[
\begin{array}{}
t^2 &amp; t &amp; 1 \\
\end{array}
\right]
\cdot
\left[
\begin{array}{}
1 &amp; -2 &amp; 1 \\
-2 &amp; 2 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
\end{array}
\right]
\cdot
\left[
\begin{array}{}
P_0 \\
P_1 \\
P_2
\end{array}
\right]
\quad t\in[0,1]
$$</span></p>
<h4 id="三次-bezier-曲线">4.3.4 三次 Bezier 曲线</h4>
<p>当 <span class="math inline">n=3</span> 时，有 <span
class="math inline">4</span> 个控制点 <span
class="math inline">P<sub>0</sub></span>、<span
class="math inline">P<sub>1</sub></span>、<span
class="math inline">P<sub>2</sub></span> 和 <span
class="math inline">P<sub>3</sub></span>，Bezier 多项式是三次多项式：
<span class="math display">$$
p(t)=\sum_{i=0}^{3}P_iB_{i,3}(t)=P_0B_{0,3}(t)+P_1B_{1,3}(t)+P_2B_{2,3}(t)+P_3B_{3,3}(t)
$$</span> 求解 <span
class="math inline"><em>B</em><sub>0, 3</sub></span>、<span
class="math inline"><em>B</em><sub>1, 3</sub></span>、<span
class="math inline"><em>B</em><sub>2, 3</sub></span> 和 <span
class="math inline"><em>B</em><sub>3, 3</sub></span>： <span
class="math display">$$
\begin{aligned}
&amp;B_{0,3}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{3!}{0!(3-0)!}t^0(1-t)^{3-0}=(1-t)^3\\
&amp;B_{1,3}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{3!}{1!(3-1)!}t^1(1-t)^{3-1}=3t(1-t)^2\\
&amp;B_{2,3}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{3!}{2!(3-2)!}t^2(1-t)^{3-2}=3t^2(1-t)\\
&amp;B_{3,3}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}=\frac{3!}{3!(3-3)!}t^3(1-t)^{3-3}=t^3\\
\end{aligned}
$$</span> 最后化简得到的三次 Bezier 曲线的方程为： <span
class="math display"><em>p</em>(<em>t</em>) = (1−<em>t</em>)<sup>3</sup><em>P</em><sub>0</sub> + 3<em>t</em>(1−<em>t</em>)<sup>2</sup><em>P</em><sub>1</sub> + 3<em>t</em><sup>2</sup>(1−<em>t</em>)<em>P</em><sub>2</sub> + <em>t</em><sup>3</sup><em>P</em><sub>3</sub></span>
将三次 Bezier 曲线写为矩阵形式： <span class="math display">$$
\begin{aligned}
p(t)&amp;=\left[
\begin{array}{}
t^3 &amp; t^2 &amp; t &amp; 1 \\
\end{array}
\right]
\cdot
\left[
\begin{array}{}
-1 &amp; 3 &amp; -3 &amp; 1 \\
3 &amp; -6 &amp; 3 &amp; 0 \\
-3 &amp; 3 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 0 &amp; 0
\end{array}
\right]
\cdot
\left[
\begin{array}{}
P_0 \\
P_1 \\
P_2 \\
P_3
\end{array}
\right]
\quad t\in[0,1]\\
&amp;=T\cdot M_{be}\cdot G_{be}
\end{aligned}
$$</span> 其中，<span
class="math inline"><em>M</em><sub><em>b</em><em>e</em></sub></span>
是三次 Bezier 曲线的系数矩阵，为常数；<span
class="math inline"><em>G</em><sub><em>b</em><em>e</em></sub></span> 是
<span class="math inline">4</span> 个控制点位置矢量。</p>
<p>下面是一个用 python 实现的绘制三次 Bezier 曲线的示意图：</p>
<p><img src="/img/计算机图形学-21.gif" /></p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/2023/12/11/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8A%80%E6%9C%AF/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    人工智能技术杂谈
                
            </div>
        </a>
    
    
        <a href="/2023/10/24/Transformer/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">Transformer</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>